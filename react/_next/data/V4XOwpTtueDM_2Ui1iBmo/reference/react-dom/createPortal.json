{"pageProps":{"content":"[[\"$r\",\"MaxWidth\",\"46\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"createPortal\"}],\" 允许你将 JSX 作为 children 渲染至 DOM 的不同部分。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"<div>\\r\\n  <SomeComponent />\\r\\n  {createPortal(children, domNode, key?)}\\r\\n</div>\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"createportal\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"createPortal(children, domNode, key?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"createPortal\"}],\" 创建 portal，并传入 JSX 与实际渲染的目标 DOM 节点：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createPortal } from 'react-dom';\\r\\n\\r\\n// ...\\r\\n\\r\\n<div>\\r\\n  <p>这个子节点被放置在父节点 div 中。</p>\\r\\n  {createPortal(\\r\\n    <p>这个子节点被放置在 document body 中。</p>,\\r\\n    document.body\\r\\n  )}\\r\\n</div>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"参见下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"portal 只改变 DOM 节点的所处位置。在其他方面，渲染至 portal 的 JSX 的行为表现与作为 React 组件的子节点一致。该子节点可以访问由父节点树提供的 context 对象、事件将从子节点依循 React 树冒泡到父节点。\"}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"children\"}],\"：React 可以渲染的任何内容，如 JSX 片段（\",[\"$r\",\"code\",null,{\"children\":\"<div />\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"<SomeComponent />\"}],\" 等等）、\",[\"$r\",\"a\",null,{\"href\":\"/reference/react/Fragment\",\"children\":\"Fragment\"}],\"（\",[\"$r\",\"code\",null,{\"children\":\"<>...</>\"}],\"）、字符串或数字，以及这些内容构成的数组。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"domNode\"}],\"：某个已经存在的 DOM 节点，例如由 \",[\"$r\",\"code\",null,{\"children\":\"document.getElementById()\"}],\" 返回的节点。在更新过程中传递不同的 DOM 节点将导致 portal 内容被重建。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选参数\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"：用作 portal \",[\"$r\",\"a\",null,{\"href\":\"/learn/rendering-lists/#keeping-list-items-in-order-with-key\",\"children\":\"key\"}],\" 的独特字符串或数字。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"createPortal\"}],\" 返回一个可以包含在 JSX 中或从 React 组件中返回的 React 节点。如果 React 在渲染输出中遇见它，它将把提供的 \",[\"$r\",\"code\",null,{\"children\":\"children\"}],\" 放入提供的 \",[\"$r\",\"code\",null,{\"children\":\"domNode\"}],\" 中。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"警告 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"portal 中的事件传播遵循 React 树而不是 DOM 树。例如点击 \",[\"$r\",\"code\",null,{\"children\":\"<div onClick>\"}],\" 内部的 portal，将触发 \",[\"$r\",\"code\",null,{\"children\":\"onClick\"}],\" 处理程序。如果这会导致意外的问题，请在 portal 内部停止事件传播，或将 portal 移动到 React 树中的上层。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-to-a-different-part-of-the-dom\",\"children\":\"渲染到 DOM 的不同部分 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"em\",null,{\"children\":\"portal\"}],\" 允许组件将它们的某些子元素渲染到 DOM 中的不同位置。这使得组件的一部分可以“逃脱”它所在的容器。例如组件可以在页面其余部分上方或外部显示模态对话框和提示框。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"createPortal\"}],\" 并传入 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"JSX\"}],\" 与 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\" 应该放置的 DOM 节点\"}],\" 作为参数，然后渲染返回值以创建 portal：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 8, \\\"<p>这个子节点被放置在 document body 中。</p>\\\"], [2, 9, \\\"document.body\\\"]]\",\"children\":\"import { createPortal } from 'react-dom';\\r\\n\\r\\nfunction MyComponent() {\\r\\n  return (\\r\\n    <div style={{ border: '2px solid black' }}>\\r\\n      <p>这个子节点被放置在父节点 div 中。</p>\\r\\n      {createPortal(\\r\\n        <p>这个子节点被放置在 document body 中。</p>,\\r\\n        document.body\\r\\n      )}\\r\\n    </div>\\r\\n  );\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 将 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"传递的 JSX\"}],\" 对应的 DOM 节点放入 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"提供的 DOM 节点\"}],\" 中。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果没有 portal，第二个 \",[\"$r\",\"code\",null,{\"children\":\"<p>\"}],\" 将放置在父级 \",[\"$r\",\"code\",null,{\"children\":\"<div>\"}],\" 中，但 portal 会将其“传送”到 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/API/Document/body\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"document.body\"}]}],\" 中：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createPortal } from 'react-dom';\\r\\n\\r\\nexport default function MyComponent() {\\r\\n  return (\\r\\n    <div style={{ border: '2px solid black' }}>\\r\\n      <p>这个子节点被放置在父节点 div 中。</p>\\r\\n      {createPortal(\\r\\n        <p>这个子节点被放置在 document body 中。</p>,\\r\\n        document.body\\r\\n      )}\\r\\n    </div>\\r\\n  );\\r\\n}\\n\"}]}]}],[\"$r\",\"MaxWidth\",\"62\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意，第二个段落在视觉上出现在带有边框的父级 \",[\"$r\",\"code\",null,{\"children\":\"<div>\"}],\" 之外。如果你使用开发者工具检查 DOM 结构，会发现第二个 \",[\"$r\",\"code\",null,{\"children\":\"<p>\"}],\" 直接放置在 \",[\"$r\",\"code\",null,{\"children\":\"<body>\"}],\" 中：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-html\",\"meta\":\"{4-6,9}\",\"children\":\"<body>\\r\\n  <div id=\\\"root\\\">\\r\\n    ...\\r\\n      <div style=\\\"border: 2px solid black\\\">\\r\\n        <p>这个子节点被放置在父节点 div 中。</p>\\r\\n      </div>\\r\\n    ...\\r\\n  </div>\\r\\n  <p>这个子节点被放置在 document body 中。</p>\\r\\n</body>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"portal 只改变 DOM 节点的所处位置。在其他方面，portal 中的 JSX 将作为实际渲染它的 React 组件的子节点。该子节点可以访问由父节点树提供的 context 对象、事件将仍然从子节点冒泡到父节点树。\"}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-a-modal-dialog-with-a-portal\",\"children\":\"使用 portal 渲染模态对话框 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以使用 portal 创建一个浮动在页面其余部分之上的模态对话框，即使呼出对话框的组件位于带有 \",[\"$r\",\"code\",null,{\"children\":\"overflow: hidden\"}],\" 或其他干扰对话框样式的容器中。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在此示例中，这两个容器具有破坏模态对话框的样式，但是渲染到 portal 中的容器不受影响，因为在 DOM 中，模态对话框不包含在父 JSX 元素内部。\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js active\",\"children\":\"import NoPortalExample from './NoPortalExample';\\r\\nimport PortalExample from './PortalExample';\\r\\n\\r\\nexport default function App() {\\r\\n  return (\\r\\n    <>\\r\\n      <div className=\\\"clipping-container\\\">\\r\\n        <NoPortalExample  />\\r\\n      </div>\\r\\n      <div className=\\\"clipping-container\\\">\\r\\n        <PortalExample />\\r\\n      </div>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/NoPortalExample.js\",\"children\":\"import { useState } from 'react';\\r\\nimport ModalContent from './ModalContent.js';\\r\\n\\r\\nexport default function NoPortalExample() {\\r\\n  const [showModal, setShowModal] = useState(false);\\r\\n  return (\\r\\n    <>\\r\\n      <button onClick={() => setShowModal(true)}>\\r\\n        不使用 portal 展示模态（modal）\\r\\n      </button>\\r\\n      {showModal && (\\r\\n        <ModalContent onClose={() => setShowModal(false)} />\\r\\n      )}\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/PortalExample.js active\",\"children\":\"import { useState } from 'react';\\r\\nimport { createPortal } from 'react-dom';\\r\\nimport ModalContent from './ModalContent.js';\\r\\n\\r\\nexport default function PortalExample() {\\r\\n  const [showModal, setShowModal] = useState(false);\\r\\n  return (\\r\\n    <>\\r\\n      <button onClick={() => setShowModal(true)}>\\r\\n        使用 portal 展示模态（motal）\\r\\n      </button>\\r\\n      {showModal && createPortal(\\r\\n        <ModalContent onClose={() => setShowModal(false)} />,\\r\\n        document.body\\r\\n      )}\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ModalContent.js\",\"children\":\"export default function ModalContent({ onClose }) {\\r\\n  return (\\r\\n    <div className=\\\"modal\\\">\\r\\n      <div>这是一个模态对话框</div>\\r\\n      <button onClick={onClose}>关闭</button>\\r\\n    </div>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"meta\":\"src/styles.css\",\"children\":\".clipping-container {\\r\\n  position: relative;\\r\\n  border: 1px solid #aaa;\\r\\n  margin-bottom: 12px;\\r\\n  padding: 12px;\\r\\n  width: 250px;\\r\\n  height: 80px;\\r\\n  overflow: hidden;\\r\\n}\\r\\n\\r\\n.modal {\\r\\n  display: flex;\\r\\n  justify-content: space-evenly;\\r\\n  align-items: center;\\r\\n  box-shadow: rgba(100, 100, 111, 0.3) 0px 7px 29px 0px;\\r\\n  background-color: white;\\r\\n  border: 2px solid rgb(240, 240, 240);\\r\\n  border-radius: 12px;\\r\\n  position:  absolute;\\r\\n  width: 250px;\\r\\n  top: 70px;\\r\\n  left: calc(50% - 125px);\\r\\n  bottom: 70px;\\r\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"72\",{\"children\":[\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"使用 portal 时，确保应用程序的无障碍性非常重要。例如，你可能需要管理键盘焦点，以便用户可以自然进出 portal。\"}],[\"$r\",\"p\",null,{\"children\":[\"创建模态对话框时，请遵循 \",[\"$r\",\"a\",null,{\"href\":\"https://www.w3.org/WAI/ARIA/apg/#dialog_modal\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"WAI-ARIA 模态实践指南\"}],\"。如果你使用了社区包，请确保它具有无障碍性，并遵循这些指南。\"]}]]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-react-components-into-non-react-server-markup\",\"children\":\"将 React 组件渲染到非 React 服务器标记中 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果静态或服务端渲染的网站中只有某一部分使用 React，则 portal 可能非常有用。如果你的页面使用 Rails 等服务端框架构建，则可以在静态区域（例如侧边栏）中创建交互区域。与拥有 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/client/createRoot#rendering-a-page-partially-built-with-react\",\"children\":\"多个独立的 React 根\"}],\" 相比，portal 将应用程序视为一个单一的 React 树，即使它的部分在 DOM 的不同部分渲染，也可以共享状态。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-html\",\"meta\":\"index.html\",\"children\":\"<!DOCTYPE html>\\r\\n<html>\\r\\n  <head><title>我的应用程序</title></head>\\r\\n  <body>\\r\\n    <h1>我的网站一部分使用了 React，另外一部分没有使用</h1>\\r\\n    <div class=\\\"parent\\\">\\r\\n      <div class=\\\"sidebar\\\">\\r\\n        这是一个非 React 服务器标记\\r\\n        <div id=\\\"sidebar-content\\\"></div>\\r\\n      </div>\\r\\n      <div id=\\\"root\\\"></div>\\r\\n    </div>\\r\\n  </body>\\r\\n</html>\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/index.js\",\"children\":\"import { StrictMode } from 'react';\\r\\nimport { createRoot } from 'react-dom/client';\\r\\nimport App from './App.js';\\r\\nimport './styles.css';\\r\\n\\r\\nconst root = createRoot(document.getElementById('root'));\\r\\nroot.render(\\r\\n  <StrictMode>\\r\\n    <App />\\r\\n  </StrictMode>\\r\\n);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js active\",\"children\":\"import { createPortal } from 'react-dom';\\r\\n\\r\\nconst sidebarContentEl = document.getElementById('sidebar-content');\\r\\n\\r\\nexport default function App() {\\r\\n  return (\\r\\n    <>\\r\\n      <MainContent />\\r\\n      {createPortal(\\r\\n        <SidebarContent />,\\r\\n        sidebarContentEl\\r\\n      )}\\r\\n    </>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction MainContent() {\\r\\n  return <p>这一部分是被 React 渲染的。</p>;\\r\\n}\\r\\n\\r\\nfunction SidebarContent() {\\r\\n  return <p>这一部分也是被 React 渲染的！</p>;\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".parent {\\r\\n  display: flex;\\r\\n  flex-direction: row;\\r\\n}\\r\\n\\r\\n#root {\\r\\n  margin-top: 12px;\\r\\n}\\r\\n\\r\\n.sidebar {\\r\\n  padding:  12px;\\r\\n  background-color: #eee;\\r\\n  width: 200px;\\r\\n  height: 200px;\\r\\n  margin-right: 12px;\\r\\n}\\r\\n\\r\\n#sidebar-content {\\r\\n  margin-top: 18px;\\r\\n  display: block;\\r\\n  background-color: white;\\r\\n}\\r\\n\\r\\np {\\r\\n  margin: 0;\\r\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"92\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"rendering-react-components-into-non-react-dom-nodes\",\"children\":\"将 React 组件渲染到非 React DOM 节点 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你还可以使用 portal 来管理在 React 之外管理的 DOM 节点的内容。假设你正在集成非 React 地图小部件，并且想要在弹出窗口中渲染 React 内容，那么可以声明一个 \",[\"$r\",\"code\",null,{\"children\":\"popupContainer\"}],\" state 变量来存储要渲染到的目标 DOM 节点：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [popupContainer, setPopupContainer] = useState(null);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在创建第三方小部件时，存储由小部件返回的 DOM 节点，以便可以将内容渲染到其中：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5-6}\",\"children\":\"useEffect(() => {\\r\\n  if (mapRef.current === null) {\\r\\n    const map = createMapWidget(containerRef.current);\\r\\n    mapRef.current = map;\\r\\n    const popupDiv = addPopupToMapWidget(map);\\r\\n    setPopupContainer(popupDiv);\\r\\n  }\\r\\n}, []);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这样，一旦 \",[\"$r\",\"code\",null,{\"children\":\"popupContainer\"}],\" 可用，就可以使用 \",[\"$r\",\"code\",null,{\"children\":\"createPortal\"}],\" 将 React 内容渲染到其中：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3-6}\",\"children\":\"return (\\r\\n  <div style={{ width: 250, height: 250 }} ref={containerRef}>\\r\\n    {popupContainer !== null && createPortal(\\r\\n      <p>来自 React 的你，你好！</p>,\\r\\n      popupContainer\\r\\n    )}\\r\\n  </div>\\r\\n);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"以下是一个完整的示例，你可以尝试一下：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json hidden\",\"children\":\"{\\r\\n  \\\"dependencies\\\": {\\r\\n    \\\"leaflet\\\": \\\"1.9.1\\\",\\r\\n    \\\"react\\\": \\\"latest\\\",\\r\\n    \\\"react-dom\\\": \\\"latest\\\",\\r\\n    \\\"react-scripts\\\": \\\"latest\\\",\\r\\n    \\\"remarkable\\\": \\\"2.0.1\\\"\\r\\n  },\\r\\n  \\\"scripts\\\": {\\r\\n    \\\"start\\\": \\\"react-scripts start\\\",\\r\\n    \\\"build\\\": \\\"react-scripts build\\\",\\r\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\r\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\r\\n  }\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useRef, useEffect, useState } from 'react';\\r\\nimport { createPortal } from 'react-dom';\\r\\nimport { createMapWidget, addPopupToMapWidget } from './map-widget.js';\\r\\n\\r\\nexport default function Map() {\\r\\n  const containerRef = useRef(null);\\r\\n  const mapRef = useRef(null);\\r\\n  const [popupContainer, setPopupContainer] = useState(null);\\r\\n\\r\\n  useEffect(() => {\\r\\n    if (mapRef.current === null) {\\r\\n      const map = createMapWidget(containerRef.current);\\r\\n      mapRef.current = map;\\r\\n      const popupDiv = addPopupToMapWidget(map);\\r\\n      setPopupContainer(popupDiv);\\r\\n    }\\r\\n  }, []);\\r\\n\\r\\n  return (\\r\\n    <div style={{ width: 250, height: 250 }} ref={containerRef}>\\r\\n      {popupContainer !== null && createPortal(\\r\\n        <p>来自 React 的你，你好！</p>,\\r\\n        popupContainer\\r\\n      )}\\r\\n    </div>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/map-widget.js\",\"children\":\"import 'leaflet/dist/leaflet.css';\\r\\nimport * as L from 'leaflet';\\r\\n\\r\\nexport function createMapWidget(containerDomNode) {\\r\\n  const map = L.map(containerDomNode);\\r\\n  map.setView([0, 0], 0);\\r\\n  L.tileLayer('https://tile.openstreetmap.org/{z}/{x}/{y}.png', {\\r\\n    maxZoom: 19,\\r\\n    attribution: '© OpenStreetMap'\\r\\n  }).addTo(map);\\r\\n  return map;\\r\\n}\\r\\n\\r\\nexport function addPopupToMapWidget(map) {\\r\\n  const popupDiv = document.createElement('div');\\r\\n  L.popup()\\r\\n    .setLatLng([0, 0])\\r\\n    .setContent(popupDiv)\\r\\n    .openOn(map);\\r\\n  return popupDiv;\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\n\"}]}]]}]]","toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#createportal\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"createPortal(children, domNode, key?)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#rendering-to-a-different-part-of-the-dom\",\"depth\":3,\"text\":\"渲染到 DOM 的不同部分 \"},{\"url\":\"#rendering-a-modal-dialog-with-a-portal\",\"depth\":3,\"text\":\"使用 portal 渲染模态对话框 \"},{\"url\":\"#rendering-react-components-into-non-react-server-markup\",\"depth\":3,\"text\":\"将 React 组件渲染到非 React 服务器标记中 \"},{\"url\":\"#rendering-react-components-into-non-react-dom-nodes\",\"depth\":3,\"text\":\"将 React 组件渲染到非 React DOM 节点 \"}]","meta":{"title":"createPortal"}},"__N_SSG":true}