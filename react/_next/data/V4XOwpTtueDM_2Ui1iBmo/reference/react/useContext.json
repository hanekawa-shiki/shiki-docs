{"pageProps":{"content":"[[\"$r\",\"MaxWidth\",\"48\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 是一个 React Hook，可以让你读取和订阅组件中的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const value = useContext(SomeContext)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"usecontext\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext(SomeContext)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件的顶层调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 来读取和订阅 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useContext } from 'react';\\r\\n\\r\\nfunction MyComponent() {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"请看下方更多示例。\"}]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"SomeContext\"}],\"：先前用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"createContext\"}]}],\" 创建的 context。context 本身不包含信息，它只代表你可以提供或从组件中读取的信息类型。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 为调用组件返回 context 的值。它被确定为传递给树中调用组件上方最近的 \",[\"$r\",\"code\",null,{\"children\":\"SomeContext.Provider\"}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\"。如果没有这样的 provider，那么返回值将会是为创建该 context 传递给 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createContext\",\"children\":[\"$r\",\"code\",null,{\"children\":\"createContext\"}]}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"defaultValue\"}],\"。返回的值始终是最新的。如果 context 发生变化，React 会自动重新渲染读取 context 的组件。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"组件中的 \",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 调用不受 \",[\"$r\",\"strong\",null,{\"children\":\"同一\"}],\" 组件返回的 provider 的影响。相应的 \",[\"$r\",\"code\",null,{\"children\":\"<Context.Provider>\"}],\" 需要位于调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 的组件 \",[\"$r\",\"strong\",null,{\"children\":\"之上\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"从 provider 接收到不同的 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\" 开始，React 自动重新渲染使用了该特定 context 的所有子级。先前的值和新的值会使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 来做比较。使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"memo\"}]}],\" 来跳过重新渲染并不妨碍子级接收到新的 context 值。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"如果您的构建系统在输出中产生重复的模块（可能发生在符号链接中），这可能会破坏 context。通过 context 传递数据只有在用于传递 context 的 \",[\"$r\",\"code\",null,{\"children\":\"SomeContext\"}],\" 和用于读取数据的  \",[\"$r\",\"code\",null,{\"children\":\"SomeContext\"}],\" 是完全相同的对象时才有效，这是由 \",[\"$r\",\"code\",null,{\"children\":\"===\"}],\" 比较决定的。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"passing-data-deeply-into-the-tree\",\"children\":\"向组件树深层传递数据 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件的最顶级调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 来读取和订阅 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"context\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 4, \\\"theme\\\"], [1, 4, \\\"ThemeContext\\\"]]\",\"children\":\"import { useContext } from 'react';\\r\\n\\r\\nfunction Button() {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  // ... \\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext\"}],\" 返回你向 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"context\"}],\" 传递的 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"context value\"}],\"。为了确定 context 值，React 搜索组件树，为这个特定的 context \",[\"$r\",\"strong\",null,{\"children\":\"向上查找最近的\"}],\" context provider。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"若要将 context 传递给 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\"，请将其或其父组件之一包装到相应的 context provider：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 3, \\\"ThemeContext\\\"], [2, 3, \\\"\\\\\\\"dark\\\\\\\"\\\"], [1, 5, \\\"ThemeContext\\\"]]\",\"children\":\"function MyPage() {\\r\\n  return (\\r\\n    <ThemeContext.Provider value=\\\"dark\\\">\\r\\n      <Form />\\r\\n    </ThemeContext.Provider>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Form() {\\r\\n  // ... 在内部渲染 buttons ...\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"provider 和 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 之间有多少层组件并不重要。当 \",[\"$r\",\"code\",null,{\"children\":\"Form\"}],\" 中的任何位置的 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext(ThemeContext)\"}],\" 时，它都将接收 \",[\"$r\",\"code\",null,{\"children\":\"\\\"dark\\\"\"}],\" 作为值。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 总是在调用它的组件 \",[\"$r\",\"strong\",null,{\"children\":\"上面\"}],\" 寻找最近的 provider。它向上搜索， \",[\"$r\",\"strong\",null,{\"children\":\"不考虑\"}],\" 调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 的组件中的 provider。\"]}]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext } from 'react';\\r\\n\\r\\nconst ThemeContext = createContext(null);\\r\\n\\r\\nexport default function MyApp() {\\r\\n  return (\\r\\n    <ThemeContext.Provider value=\\\"dark\\\">\\r\\n      <Form />\\r\\n    </ThemeContext.Provider>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Form() {\\r\\n  return (\\r\\n    <Panel title=\\\"Welcome\\\">\\r\\n      <Button>Sign up</Button>\\r\\n      <Button>Log in</Button>\\r\\n    </Panel>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Panel({ title, children }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'panel-' + theme;\\r\\n  return (\\r\\n    <section className={className}>\\r\\n      <h1>{title}</h1>\\r\\n      {children}\\r\\n    </section>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Button({ children }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'button-' + theme;\\r\\n  return (\\r\\n    <button className={className}>\\r\\n      {children}\\r\\n    </button>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".panel-light,\\r\\n.panel-dark {\\r\\n  border: 1px solid black;\\r\\n  border-radius: 4px;\\r\\n  padding: 20px;\\r\\n}\\r\\n.panel-light {\\r\\n  color: #222;\\r\\n  background: #fff;\\r\\n}\\r\\n\\r\\n.panel-dark {\\r\\n  color: #fff;\\r\\n  background: rgb(23, 32, 42);\\r\\n}\\r\\n\\r\\n.button-light,\\r\\n.button-dark {\\r\\n  border: 1px solid #777;\\r\\n  padding: 5px;\\r\\n  margin-right: 10px;\\r\\n  margin-top: 10px;\\r\\n}\\r\\n\\r\\n.button-dark {\\r\\n  background: #222;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.button-light {\\r\\n  background: #fff;\\r\\n  color: #222;\\r\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"60\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"updating-data-passed-via-context\",\"children\":\"通过 context 更新传递的数据 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常，你会希望 context 随着时间的推移而改变。要更新 context，请将其与 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":\"state\"}],\" 结合。在父组件中声明一个状态变量，并将当前状态作为 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"context value\"}],\" 传递给 provider。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{2} [[1, 4, \\\"ThemeContext\\\"], [2, 4, \\\"theme\\\"], [1, 11, \\\"ThemeContext\\\"]]\",\"children\":\"function MyPage() {\\r\\n  const [theme, setTheme] = useState('dark');\\r\\n  return (\\r\\n    <ThemeContext.Provider value={theme}>\\r\\n      <Form />\\r\\n      <Button onClick={() => {\\r\\n        setTheme('light');\\r\\n      }}>\\r\\n       Switch to light theme\\r\\n      </Button>\\r\\n    </ThemeContext.Provider>\\r\\n  );\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在 provider 中的任何一个 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 都会接收到当前的 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 值。如果调用 \",[\"$r\",\"code\",null,{\"children\":\"setTheme\"}],\" 来更新传递给 provider 的 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 值，则所有 \",[\"$r\",\"code\",null,{\"children\":\"Button\"}],\" 组件都将使用新的值 \",[\"$r\",\"code\",null,{\"children\":\"'light'\"}],\" 来重新渲染。\"]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"更新 context 的例子\",\"titleId\":\"examples-basic\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"updating-a-value-via-context\",\"children\":\"通过 context 来更新数据 \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个示例中，\",[\"$r\",\"code\",null,{\"children\":\"MyApp\"}],\" 组件包含一个状态变量，然后该变量被传递给 \",[\"$r\",\"code\",null,{\"children\":\"ThemeContext\"}],\" provider。选中“Dark mode”复选框更新状态。更改提供的值将重新渲染使用该 context 的所有组件。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext, useState } from 'react';\\r\\n\\r\\nconst ThemeContext = createContext(null);\\r\\n\\r\\nexport default function MyApp() {\\r\\n  const [theme, setTheme] = useState('light');\\r\\n  return (\\r\\n    <ThemeContext.Provider value={theme}>\\r\\n      <Form />\\r\\n      <label>\\r\\n        <input\\r\\n          type=\\\"checkbox\\\"\\r\\n          checked={theme === 'dark'}\\r\\n          onChange={(e) => {\\r\\n            setTheme(e.target.checked ? 'dark' : 'light')\\r\\n          }}\\r\\n        />\\r\\n        Use dark mode\\r\\n      </label>\\r\\n    </ThemeContext.Provider>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Form({ children }) {\\r\\n  return (\\r\\n    <Panel title=\\\"Welcome\\\">\\r\\n      <Button>Sign up</Button>\\r\\n      <Button>Log in</Button>\\r\\n    </Panel>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Panel({ title, children }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'panel-' + theme;\\r\\n  return (\\r\\n    <section className={className}>\\r\\n      <h1>{title}</h1>\\r\\n      {children}\\r\\n    </section>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Button({ children }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'button-' + theme;\\r\\n  return (\\r\\n    <button className={className}>\\r\\n      {children}\\r\\n    </button>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".panel-light,\\r\\n.panel-dark {\\r\\n  border: 1px solid black;\\r\\n  border-radius: 4px;\\r\\n  padding: 20px;\\r\\n  margin-bottom: 10px;\\r\\n}\\r\\n.panel-light {\\r\\n  color: #222;\\r\\n  background: #fff;\\r\\n}\\r\\n\\r\\n.panel-dark {\\r\\n  color: #fff;\\r\\n  background: rgb(23, 32, 42);\\r\\n}\\r\\n\\r\\n.button-light,\\r\\n.button-dark {\\r\\n  border: 1px solid #777;\\r\\n  padding: 5px;\\r\\n  margin-right: 10px;\\r\\n  margin-top: 10px;\\r\\n}\\r\\n\\r\\n.button-dark {\\r\\n  background: #222;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.button-light {\\r\\n  background: #fff;\\r\\n  color: #222;\\r\\n}\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"注意，\",[\"$r\",\"code\",null,{\"children\":\"value=\\\"dark\\\"\"}],\" 传递 \",[\"$r\",\"code\",null,{\"children\":\"\\\"dark\\\"\"}],\" 字符串，但 \",[\"$r\",\"code\",null,{\"children\":\"value={theme}\"}],\" 传递带有 \",[\"$r\",\"a\",null,{\"href\":\"/learn/javascript-in-jsx-with-curly-braces\",\"children\":\"JSX 花括号\"}],\" 的 JavaScript \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 变量的值。花括号还允许传递非字符串的 context 值。\"]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"updating-an-object-via-context\",\"children\":\"通过 context 更新对象 \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，有一个 \",[\"$r\",\"code\",null,{\"children\":\"currentUser\"}],\" 状态变量，它包含一个对象。将 \",[\"$r\",\"code\",null,{\"children\":\"{ currentUser, setCurrentUser }\"}],\" 组合成一个对象，并通过 context 在 \",[\"$r\",\"code\",null,{\"children\":\"value={}\"}],\" 中向下传递。这允许下面的任何组件，如 \",[\"$r\",\"code\",null,{\"children\":\"LoginButton\"}],\"，同时读取 \",[\"$r\",\"code\",null,{\"children\":\"currentUser\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"setCurrentUser\"}],\"，然后在需要时调用 \",[\"$r\",\"code\",null,{\"children\":\"setCurrentUser\"}],\"。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext, useState } from 'react';\\r\\n\\r\\nconst CurrentUserContext = createContext(null);\\r\\n\\r\\nexport default function MyApp() {\\r\\n  const [currentUser, setCurrentUser] = useState(null);\\r\\n  return (\\r\\n    <CurrentUserContext.Provider\\r\\n      value={{\\r\\n        currentUser,\\r\\n        setCurrentUser\\r\\n      }}\\r\\n    >\\r\\n      <Form />\\r\\n    </CurrentUserContext.Provider>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Form({ children }) {\\r\\n  return (\\r\\n    <Panel title=\\\"Welcome\\\">\\r\\n      <LoginButton />\\r\\n    </Panel>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction LoginButton() {\\r\\n  const {\\r\\n    currentUser,\\r\\n    setCurrentUser\\r\\n  } = useContext(CurrentUserContext);\\r\\n\\r\\n  if (currentUser !== null) {\\r\\n    return <p>You logged in as {currentUser.name}.</p>;\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <Button onClick={() => {\\r\\n      setCurrentUser({ name: 'Advika' })\\r\\n    }}>Log in as Advika</Button>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Panel({ title, children }) {\\r\\n  return (\\r\\n    <section className=\\\"panel\\\">\\r\\n      <h1>{title}</h1>\\r\\n      {children}\\r\\n    </section>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Button({ children, onClick }) {\\r\\n  return (\\r\\n    <button className=\\\"button\\\" onClick={onClick}>\\r\\n      {children}\\r\\n    </button>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label {\\r\\n  display: block;\\r\\n}\\r\\n\\r\\n.panel {\\r\\n  border: 1px solid black;\\r\\n  border-radius: 4px;\\r\\n  padding: 20px;\\r\\n  margin-bottom: 10px;\\r\\n}\\r\\n\\r\\n.button {\\r\\n  border: 1px solid #777;\\r\\n  padding: 5px;\\r\\n  margin-right: 10px;\\r\\n  margin-top: 10px;\\r\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"multiple-contexts\",\"children\":\"同时使用多个 context \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个例子中，存在两个独立的 context。\",[\"$r\",\"code\",null,{\"children\":\"ThemeContext\"}],\" 提供了当前的主题，它是一个字符串，而 \",[\"$r\",\"code\",null,{\"children\":\"CurrentUserContext\"}],\" 保存了代表当前用户的对象。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext, useState } from 'react';\\r\\n\\r\\nconst ThemeContext = createContext(null);\\r\\nconst CurrentUserContext = createContext(null);\\r\\n\\r\\nexport default function MyApp() {\\r\\n  const [theme, setTheme] = useState('light');\\r\\n  const [currentUser, setCurrentUser] = useState(null);\\r\\n  return (\\r\\n    <ThemeContext.Provider value={theme}>\\r\\n      <CurrentUserContext.Provider\\r\\n        value={{\\r\\n          currentUser,\\r\\n          setCurrentUser\\r\\n        }}\\r\\n      >\\r\\n        <WelcomePanel />\\r\\n        <label>\\r\\n          <input\\r\\n            type=\\\"checkbox\\\"\\r\\n            checked={theme === 'dark'}\\r\\n            onChange={(e) => {\\r\\n              setTheme(e.target.checked ? 'dark' : 'light')\\r\\n            }}\\r\\n          />\\r\\n          Use dark mode\\r\\n        </label>\\r\\n      </CurrentUserContext.Provider>\\r\\n    </ThemeContext.Provider>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction WelcomePanel({ children }) {\\r\\n  const {currentUser} = useContext(CurrentUserContext);\\r\\n  return (\\r\\n    <Panel title=\\\"Welcome\\\">\\r\\n      {currentUser !== null ?\\r\\n        <Greeting /> :\\r\\n        <LoginForm />\\r\\n      }\\r\\n    </Panel>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Greeting() {\\r\\n  const {currentUser} = useContext(CurrentUserContext);\\r\\n  return (\\r\\n    <p>You logged in as {currentUser.name}.</p>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction LoginForm() {\\r\\n  const {setCurrentUser} = useContext(CurrentUserContext);\\r\\n  const [firstName, setFirstName] = useState('');\\r\\n  const [lastName, setLastName] = useState('');\\r\\n  const canLogin = firstName !== '' && lastName !== '';\\r\\n  return (\\r\\n    <>\\r\\n      <label>\\r\\n        First name{': '}\\r\\n        <input\\r\\n          required\\r\\n          value={firstName}\\r\\n          onChange={e => setFirstName(e.target.value)}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Last name{': '}\\r\\n        <input\\r\\n        required\\r\\n          value={lastName}\\r\\n          onChange={e => setLastName(e.target.value)}\\r\\n        />\\r\\n      </label>\\r\\n      <Button\\r\\n        disabled={!canLogin}\\r\\n        onClick={() => {\\r\\n          setCurrentUser({\\r\\n            name: firstName + ' ' + lastName\\r\\n          });\\r\\n        }}\\r\\n      >\\r\\n        Log in\\r\\n      </Button>\\r\\n      {!canLogin && <i>Fill in both fields.</i>}\\r\\n    </>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Panel({ title, children }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'panel-' + theme;\\r\\n  return (\\r\\n    <section className={className}>\\r\\n      <h1>{title}</h1>\\r\\n      {children}\\r\\n    </section>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Button({ children, disabled, onClick }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'button-' + theme;\\r\\n  return (\\r\\n    <button\\r\\n      className={className}\\r\\n      disabled={disabled}\\r\\n      onClick={onClick}\\r\\n    >\\r\\n      {children}\\r\\n    </button>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label {\\r\\n  display: block;\\r\\n}\\r\\n\\r\\n.panel-light,\\r\\n.panel-dark {\\r\\n  border: 1px solid black;\\r\\n  border-radius: 4px;\\r\\n  padding: 20px;\\r\\n  margin-bottom: 10px;\\r\\n}\\r\\n.panel-light {\\r\\n  color: #222;\\r\\n  background: #fff;\\r\\n}\\r\\n\\r\\n.panel-dark {\\r\\n  color: #fff;\\r\\n  background: rgb(23, 32, 42);\\r\\n}\\r\\n\\r\\n.button-light,\\r\\n.button-dark {\\r\\n  border: 1px solid #777;\\r\\n  padding: 5px;\\r\\n  margin-right: 10px;\\r\\n  margin-top: 10px;\\r\\n}\\r\\n\\r\\n.button-dark {\\r\\n  background: #222;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.button-light {\\r\\n  background: #fff;\\r\\n  color: #222;\\r\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"extracting-providers-to-a-component\",\"children\":\"把 provider 抽离成组件 \"}],[\"$r\",\"p\",null,{\"children\":[\"随着你的应用增长，预计你会有一个像“金字塔”一样的 context 出现在靠近你应用的根部。这样没什么问题。然而，如果你从审美上不喜欢这种嵌套，你可以将 provider 抽离成单独的组件。在这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"MyProviders\"}],\" 隐藏了“管路”，并且在需要的 provider 中渲染传递给它的子节点。请注意，\",[\"$r\",\"code\",null,{\"children\":\"MyApp\"}],\" 本身需要 \",[\"$r\",\"code\",null,{\"children\":\"theme\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"setTheme\"}],\" 状态，因此 \",[\"$r\",\"code\",null,{\"children\":\"MyApp\"}],\" 仍然拥有这部分的状态。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext, useState } from 'react';\\r\\n\\r\\nconst ThemeContext = createContext(null);\\r\\nconst CurrentUserContext = createContext(null);\\r\\n\\r\\nexport default function MyApp() {\\r\\n  const [theme, setTheme] = useState('light');\\r\\n  return (\\r\\n    <MyProviders theme={theme} setTheme={setTheme}>\\r\\n      <WelcomePanel />\\r\\n      <label>\\r\\n        <input\\r\\n          type=\\\"checkbox\\\"\\r\\n          checked={theme === 'dark'}\\r\\n          onChange={(e) => {\\r\\n            setTheme(e.target.checked ? 'dark' : 'light')\\r\\n          }}\\r\\n        />\\r\\n        Use dark mode\\r\\n      </label>\\r\\n    </MyProviders>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction MyProviders({ children, theme, setTheme }) {\\r\\n  const [currentUser, setCurrentUser] = useState(null);\\r\\n  return (\\r\\n    <ThemeContext.Provider value={theme}>\\r\\n      <CurrentUserContext.Provider\\r\\n        value={{\\r\\n          currentUser,\\r\\n          setCurrentUser\\r\\n        }}\\r\\n      >\\r\\n        {children}\\r\\n      </CurrentUserContext.Provider>\\r\\n    </ThemeContext.Provider>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction WelcomePanel({ children }) {\\r\\n  const {currentUser} = useContext(CurrentUserContext);\\r\\n  return (\\r\\n    <Panel title=\\\"Welcome\\\">\\r\\n      {currentUser !== null ?\\r\\n        <Greeting /> :\\r\\n        <LoginForm />\\r\\n      }\\r\\n    </Panel>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Greeting() {\\r\\n  const {currentUser} = useContext(CurrentUserContext);\\r\\n  return (\\r\\n    <p>You logged in as {currentUser.name}.</p>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction LoginForm() {\\r\\n  const {setCurrentUser} = useContext(CurrentUserContext);\\r\\n  const [firstName, setFirstName] = useState('');\\r\\n  const [lastName, setLastName] = useState('');\\r\\n  const canLogin = firstName !== '' && lastName !== '';\\r\\n  return (\\r\\n    <>\\r\\n      <label>\\r\\n        First name{': '}\\r\\n        <input\\r\\n          required\\r\\n          value={firstName}\\r\\n          onChange={e => setFirstName(e.target.value)}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Last name{': '}\\r\\n        <input\\r\\n        required\\r\\n          value={lastName}\\r\\n          onChange={e => setLastName(e.target.value)}\\r\\n        />\\r\\n      </label>\\r\\n      <Button\\r\\n        disabled={!canLogin}\\r\\n        onClick={() => {\\r\\n          setCurrentUser({\\r\\n            name: firstName + ' ' + lastName\\r\\n          });\\r\\n        }}\\r\\n      >\\r\\n        Log in\\r\\n      </Button>\\r\\n      {!canLogin && <i>Fill in both fields.</i>}\\r\\n    </>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Panel({ title, children }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'panel-' + theme;\\r\\n  return (\\r\\n    <section className={className}>\\r\\n      <h1>{title}</h1>\\r\\n      {children}\\r\\n    </section>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Button({ children, disabled, onClick }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'button-' + theme;\\r\\n  return (\\r\\n    <button\\r\\n      className={className}\\r\\n      disabled={disabled}\\r\\n      onClick={onClick}\\r\\n    >\\r\\n      {children}\\r\\n    </button>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label {\\r\\n  display: block;\\r\\n}\\r\\n\\r\\n.panel-light,\\r\\n.panel-dark {\\r\\n  border: 1px solid black;\\r\\n  border-radius: 4px;\\r\\n  padding: 20px;\\r\\n  margin-bottom: 10px;\\r\\n}\\r\\n.panel-light {\\r\\n  color: #222;\\r\\n  background: #fff;\\r\\n}\\r\\n\\r\\n.panel-dark {\\r\\n  color: #fff;\\r\\n  background: rgb(23, 32, 42);\\r\\n}\\r\\n\\r\\n.button-light,\\r\\n.button-dark {\\r\\n  border: 1px solid #777;\\r\\n  padding: 5px;\\r\\n  margin-right: 10px;\\r\\n  margin-top: 10px;\\r\\n}\\r\\n\\r\\n.button-dark {\\r\\n  background: #222;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.button-light {\\r\\n  background: #fff;\\r\\n  color: #222;\\r\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"scaling-up-with-context-and-a-reducer\",\"children\":\"使用 context 和 reducer 进行扩展 \"}],[\"$r\",\"p\",null,{\"children\":[\"在大型应用程序中，通常将 context 和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useReducer\",\"children\":\"reducer\"}],\" 结合起来从组件中抽离与某种状态相关的逻辑。在本例中，所有的“线路”都隐藏在 \",[\"$r\",\"code\",null,{\"children\":\"TasksContext.js\"}],\" 中，它包含一个 reducer 和两个单独 context。\"]}],[\"$r\",\"p\",null,{\"children\":[\"阅读这个例子的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/scaling-up-with-reducer-and-context\",\"children\":\"完整演示。\"}]]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import AddTask from './AddTask.js';\\r\\nimport TaskList from './TaskList.js';\\r\\nimport { TasksProvider } from './TasksContext.js';\\r\\n\\r\\nexport default function TaskApp() {\\r\\n  return (\\r\\n    <TasksProvider>\\r\\n      <h1>Day off in Kyoto</h1>\\r\\n      <AddTask />\\r\\n      <TaskList />\\r\\n    </TasksProvider>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TasksContext.js\",\"children\":\"import { createContext, useContext, useReducer } from 'react';\\r\\n\\r\\nconst TasksContext = createContext(null);\\r\\n\\r\\nconst TasksDispatchContext = createContext(null);\\r\\n\\r\\nexport function TasksProvider({ children }) {\\r\\n  const [tasks, dispatch] = useReducer(\\r\\n    tasksReducer,\\r\\n    initialTasks\\r\\n  );\\r\\n\\r\\n  return (\\r\\n    <TasksContext.Provider value={tasks}>\\r\\n      <TasksDispatchContext.Provider value={dispatch}>\\r\\n        {children}\\r\\n      </TasksDispatchContext.Provider>\\r\\n    </TasksContext.Provider>\\r\\n  );\\r\\n}\\r\\n\\r\\nexport function useTasks() {\\r\\n  return useContext(TasksContext);\\r\\n}\\r\\n\\r\\nexport function useTasksDispatch() {\\r\\n  return useContext(TasksDispatchContext);\\r\\n}\\r\\n\\r\\nfunction tasksReducer(tasks, action) {\\r\\n  switch (action.type) {\\r\\n    case 'added': {\\r\\n      return [...tasks, {\\r\\n        id: action.id,\\r\\n        text: action.text,\\r\\n        done: false\\r\\n      }];\\r\\n    }\\r\\n    case 'changed': {\\r\\n      return tasks.map(t => {\\r\\n        if (t.id === action.task.id) {\\r\\n          return action.task;\\r\\n        } else {\\r\\n          return t;\\r\\n        }\\r\\n      });\\r\\n    }\\r\\n    case 'deleted': {\\r\\n      return tasks.filter(t => t.id !== action.id);\\r\\n    }\\r\\n    default: {\\r\\n      throw Error('Unknown action: ' + action.type);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nconst initialTasks = [\\r\\n  { id: 0, text: 'Philosopher’s Path', done: true },\\r\\n  { id: 1, text: 'Visit the temple', done: false },\\r\\n  { id: 2, text: 'Drink matcha', done: false }\\r\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTask.js\",\"children\":\"import { useState, useContext } from 'react';\\r\\nimport { useTasksDispatch } from './TasksContext.js';\\r\\n\\r\\nexport default function AddTask() {\\r\\n  const [text, setText] = useState('');\\r\\n  const dispatch = useTasksDispatch();\\r\\n  return (\\r\\n    <>\\r\\n      <input\\r\\n        placeholder=\\\"Add task\\\"\\r\\n        value={text}\\r\\n        onChange={e => setText(e.target.value)}\\r\\n      />\\r\\n      <button onClick={() => {\\r\\n        setText('');\\r\\n        dispatch({\\r\\n          type: 'added',\\r\\n          id: nextId++,\\r\\n          text: text,\\r\\n        }); \\r\\n      }}>Add</button>\\r\\n    </>\\r\\n  );\\r\\n}\\r\\n\\r\\nlet nextId = 3;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js\",\"children\":\"import { useState, useContext } from 'react';\\r\\nimport { useTasks, useTasksDispatch } from './TasksContext.js';\\r\\n\\r\\nexport default function TaskList() {\\r\\n  const tasks = useTasks();\\r\\n  return (\\r\\n    <ul>\\r\\n      {tasks.map(task => (\\r\\n        <li key={task.id}>\\r\\n          <Task task={task} />\\r\\n        </li>\\r\\n      ))}\\r\\n    </ul>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Task({ task }) {\\r\\n  const [isEditing, setIsEditing] = useState(false);\\r\\n  const dispatch = useTasksDispatch();\\r\\n  let taskContent;\\r\\n  if (isEditing) {\\r\\n    taskContent = (\\r\\n      <>\\r\\n        <input\\r\\n          value={task.text}\\r\\n          onChange={e => {\\r\\n            dispatch({\\r\\n              type: 'changed',\\r\\n              task: {\\r\\n                ...task,\\r\\n                text: e.target.value\\r\\n              }\\r\\n            });\\r\\n          }} />\\r\\n        <button onClick={() => setIsEditing(false)}>\\r\\n          Save\\r\\n        </button>\\r\\n      </>\\r\\n    );\\r\\n  } else {\\r\\n    taskContent = (\\r\\n      <>\\r\\n        {task.text}\\r\\n        <button onClick={() => setIsEditing(true)}>\\r\\n          Edit\\r\\n        </button>\\r\\n      </>\\r\\n    );\\r\\n  }\\r\\n  return (\\r\\n    <label>\\r\\n      <input\\r\\n        type=\\\"checkbox\\\"\\r\\n        checked={task.done}\\r\\n        onChange={e => {\\r\\n          dispatch({\\r\\n            type: 'changed',\\r\\n            task: {\\r\\n              ...task,\\r\\n              done: e.target.checked\\r\\n            }\\r\\n          });\\r\\n        }}\\r\\n      />\\r\\n      {taskContent}\\r\\n      <button onClick={() => {\\r\\n        dispatch({\\r\\n          type: 'deleted',\\r\\n          id: task.id\\r\\n        });\\r\\n      }}>\\r\\n        Delete\\r\\n      </button>\\r\\n    </label>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\r\\nli { list-style-type: none; }\\r\\nul, li { margin: 0; padding: 0; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"80\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"specifying-a-fallback-default-value\",\"children\":\"指定后备方案默认值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果 React 没有在父树中找到该特定 \",[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"context\"}],\" 的任何 provider，\",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 返回的 context 值将等于你在 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/createContext\",\"children\":\"创建 context\"}],\" 时指定的 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"默认值\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 1, \\\"ThemeContext\\\"], [3, 1, \\\"null\\\"]]\",\"children\":\"const ThemeContext = createContext(null);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"默认值 \",[\"$r\",\"strong\",null,{\"children\":\"从不改变\"}],\"。如果你想要更新 context，请按 \",[\"$r\",\"a\",null,{\"href\":\"#updating-data-passed-via-context\",\"children\":\"上述方式\"}],\" 将其与状态一起使用。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通常，除了 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"，还有一些更有意义的值可以用作默认值，例如：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 1, \\\"ThemeContext\\\"], [3, 1, \\\"light\\\"]]\",\"children\":\"const ThemeContext = createContext('light');\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这样，如果你不小心渲染了没有相应 provider 的某个组件，它也不会出错。这也有助于你的组件在测试环境中很好地运行，而无需在测试中设置许多 provider。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在下面的例子中，“Toggle theme”按钮总是处于 light 状态，因为它位于 \",[\"$r\",\"strong\",null,{\"children\":\"任何主题的 context provider 之外\"}],\"，且 context 主题的默认值是 \",[\"$r\",\"code\",null,{\"children\":\"'light'\"}],\"。试着编辑默认主题为 \",[\"$r\",\"code\",null,{\"children\":\"'dark'\"}],\"。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext, useState } from 'react';\\r\\n\\r\\nconst ThemeContext = createContext('light');\\r\\n\\r\\nexport default function MyApp() {\\r\\n  const [theme, setTheme] = useState('light');\\r\\n  return (\\r\\n    <>\\r\\n      <ThemeContext.Provider value={theme}>\\r\\n        <Form />\\r\\n      </ThemeContext.Provider>\\r\\n      <Button onClick={() => {\\r\\n        setTheme(theme === 'dark' ? 'light' : 'dark');\\r\\n      }}>\\r\\n        Toggle theme\\r\\n      </Button>\\r\\n    </>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Form({ children }) {\\r\\n  return (\\r\\n    <Panel title=\\\"Welcome\\\">\\r\\n      <Button>Sign up</Button>\\r\\n      <Button>Log in</Button>\\r\\n    </Panel>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Panel({ title, children }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'panel-' + theme;\\r\\n  return (\\r\\n    <section className={className}>\\r\\n      <h1>{title}</h1>\\r\\n      {children}\\r\\n    </section>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Button({ children, onClick }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'button-' + theme;\\r\\n  return (\\r\\n    <button className={className} onClick={onClick}>\\r\\n      {children}\\r\\n    </button>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".panel-light,\\r\\n.panel-dark {\\r\\n  border: 1px solid black;\\r\\n  border-radius: 4px;\\r\\n  padding: 20px;\\r\\n  margin-bottom: 10px;\\r\\n}\\r\\n.panel-light {\\r\\n  color: #222;\\r\\n  background: #fff;\\r\\n}\\r\\n\\r\\n.panel-dark {\\r\\n  color: #fff;\\r\\n  background: rgb(23, 32, 42);\\r\\n}\\r\\n\\r\\n.button-light,\\r\\n.button-dark {\\r\\n  border: 1px solid #777;\\r\\n  padding: 5px;\\r\\n  margin-right: 10px;\\r\\n  margin-top: 10px;\\r\\n}\\r\\n\\r\\n.button-dark {\\r\\n  background: #222;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.button-light {\\r\\n  background: #fff;\\r\\n  color: #222;\\r\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"92\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"overriding-context-for-a-part-of-the-tree\",\"children\":\"覆盖组件树一部分的 context \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"通过在 provider 中使用不同的值包装树的某个部分，可以覆盖该部分的 context。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{3,5}\",\"children\":\"<ThemeContext.Provider value=\\\"dark\\\">\\r\\n  ...\\r\\n  <ThemeContext.Provider value=\\\"light\\\">\\r\\n    <Footer />\\r\\n  </ThemeContext.Provider>\\r\\n  ...\\r\\n</ThemeContext.Provider>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可以根据需要多次嵌套和覆盖 provider。\"}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"Examples of overriding context\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"overriding-a-theme\",\"children\":\"覆盖主题 \"}],[\"$r\",\"p\",null,{\"children\":[\"这里，与 \",[\"$r\",\"code\",null,{\"children\":\"Footer\"}],\" 外的值为（\",[\"$r\",\"code\",null,{\"children\":\"\\\"dark\\\"\"}],\"）的按钮相比，\",[\"$r\",\"strong\",null,{\"children\":\"里面\"}],\" 的按钮接收到一个不一样的 context 值（\",[\"$r\",\"code\",null,{\"children\":\"\\\"light\\\"\"}],\"）。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { createContext, useContext } from 'react';\\r\\n\\r\\nconst ThemeContext = createContext(null);\\r\\n\\r\\nexport default function MyApp() {\\r\\n  return (\\r\\n    <ThemeContext.Provider value=\\\"dark\\\">\\r\\n      <Form />\\r\\n    </ThemeContext.Provider>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Form() {\\r\\n  return (\\r\\n    <Panel title=\\\"Welcome\\\">\\r\\n      <Button>Sign up</Button>\\r\\n      <Button>Log in</Button>\\r\\n      <ThemeContext.Provider value=\\\"light\\\">\\r\\n        <Footer />\\r\\n      </ThemeContext.Provider>\\r\\n    </Panel>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Footer() {\\r\\n  return (\\r\\n    <footer>\\r\\n      <Button>Settings</Button>\\r\\n    </footer>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Panel({ title, children }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'panel-' + theme;\\r\\n  return (\\r\\n    <section className={className}>\\r\\n      {title && <h1>{title}</h1>}\\r\\n      {children}\\r\\n    </section>\\r\\n  )\\r\\n}\\r\\n\\r\\nfunction Button({ children }) {\\r\\n  const theme = useContext(ThemeContext);\\r\\n  const className = 'button-' + theme;\\r\\n  return (\\r\\n    <button className={className}>\\r\\n      {children}\\r\\n    </button>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"footer {\\r\\n  margin-top: 20px;\\r\\n  border-top: 1px solid #aaa;\\r\\n}\\r\\n\\r\\n.panel-light,\\r\\n.panel-dark {\\r\\n  border: 1px solid black;\\r\\n  border-radius: 4px;\\r\\n  padding: 20px;\\r\\n}\\r\\n.panel-light {\\r\\n  color: #222;\\r\\n  background: #fff;\\r\\n}\\r\\n\\r\\n.panel-dark {\\r\\n  color: #fff;\\r\\n  background: rgb(23, 32, 42);\\r\\n}\\r\\n\\r\\n.button-light,\\r\\n.button-dark {\\r\\n  border: 1px solid #777;\\r\\n  padding: 5px;\\r\\n  margin-right: 10px;\\r\\n  margin-top: 10px;\\r\\n}\\r\\n\\r\\n.button-dark {\\r\\n  background: #222;\\r\\n  color: #fff;\\r\\n}\\r\\n\\r\\n.button-light {\\r\\n  background: #fff;\\r\\n  color: #222;\\r\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"automatically-nested-headings\",\"children\":\"自动嵌套标题 \"}],[\"$r\",\"p\",null,{\"children\":[\"在嵌套使用 context provider 时，可以“累积”信息。在此示例中，\",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 组件记录了 \",[\"$r\",\"code\",null,{\"children\":\"LevelContext\"}],\"，该 context 指定了 section 嵌套的深度。它从父级 section 中读取 \",[\"$r\",\"code\",null,{\"children\":\"LevelContext\"}],\"，然后把 \",[\"$r\",\"code\",null,{\"children\":\"LevelContext\"}],\" 的数值加一传递给子级。因此，\",[\"$r\",\"code\",null,{\"children\":\"Heading\"}],\" 组件可以根据被 \",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 组件嵌套的层数自动决定使用 \",[\"$r\",\"code\",null,{\"children\":\"<h1>\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"<h2>\"}],\"，\",[\"$r\",\"code\",null,{\"children\":\"<h3>\"}],\"，…，中的哪种标签。\"]}],[\"$r\",\"p\",null,{\"children\":[\"阅读此示例的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"详细演示\"}]]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import Heading from './Heading.js';\\r\\nimport Section from './Section.js';\\r\\n\\r\\nexport default function Page() {\\r\\n  return (\\r\\n    <Section>\\r\\n      <Heading>Title</Heading>\\r\\n      <Section>\\r\\n        <Heading>Heading</Heading>\\r\\n        <Heading>Heading</Heading>\\r\\n        <Heading>Heading</Heading>\\r\\n        <Section>\\r\\n          <Heading>Sub-heading</Heading>\\r\\n          <Heading>Sub-heading</Heading>\\r\\n          <Heading>Sub-heading</Heading>\\r\\n          <Section>\\r\\n            <Heading>Sub-sub-heading</Heading>\\r\\n            <Heading>Sub-sub-heading</Heading>\\r\\n            <Heading>Sub-sub-heading</Heading>\\r\\n          </Section>\\r\\n        </Section>\\r\\n      </Section>\\r\\n    </Section>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Section.js\",\"children\":\"import { useContext } from 'react';\\r\\nimport { LevelContext } from './LevelContext.js';\\r\\n\\r\\nexport default function Section({ children }) {\\r\\n  const level = useContext(LevelContext);\\r\\n  return (\\r\\n    <section className=\\\"section\\\">\\r\\n      <LevelContext.Provider value={level + 1}>\\r\\n        {children}\\r\\n      </LevelContext.Provider>\\r\\n    </section>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Heading.js\",\"children\":\"import { useContext } from 'react';\\r\\nimport { LevelContext } from './LevelContext.js';\\r\\n\\r\\nexport default function Heading({ children }) {\\r\\n  const level = useContext(LevelContext);\\r\\n  switch (level) {\\r\\n    case 0:\\r\\n      throw Error('Heading must be inside a Section!');\\r\\n    case 1:\\r\\n      return <h1>{children}</h1>;\\r\\n    case 2:\\r\\n      return <h2>{children}</h2>;\\r\\n    case 3:\\r\\n      return <h3>{children}</h3>;\\r\\n    case 4:\\r\\n      return <h4>{children}</h4>;\\r\\n    case 5:\\r\\n      return <h5>{children}</h5>;\\r\\n    case 6:\\r\\n      return <h6>{children}</h6>;\\r\\n    default:\\r\\n      throw Error('Unknown level: ' + level);\\r\\n  }\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/LevelContext.js\",\"children\":\"import { createContext } from 'react';\\r\\n\\r\\nexport const LevelContext = createContext(0);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".section {\\r\\n  padding: 10px;\\r\\n  margin: 5px;\\r\\n  border-radius: 5px;\\r\\n  border: 1px solid #aaa;\\r\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"optimizing-re-renders-when-passing-objects-and-functions\",\"children\":\"在传递对象和函数时优化重新渲染 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可以通过 context 传递任何值，包括对象和函数。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 10, \\\"{ currentUser, login }\\\"]] \",\"children\":\"function MyApp() {\\r\\n  const [currentUser, setCurrentUser] = useState(null);\\r\\n\\r\\n  function login(response) {\\r\\n    storeCredentials(response.credentials);\\r\\n    setCurrentUser(response.user);\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <AuthContext.Provider value={{ currentUser, login }}>\\r\\n      <Page />\\r\\n    </AuthContext.Provider>\\r\\n  );\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"此处，\",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":\"context value\"}],\" 是一个具有两个属性的 JavaScript 对象，其中一个是函数。每当 \",[\"$r\",\"code\",null,{\"children\":\"MyApp\"}],\" 出现重新渲染（例如，路由更新）时，这里将会是一个 \",[\"$r\",\"strong\",null,{\"children\":\"不同的\"}],\" 对象指向 \",[\"$r\",\"strong\",null,{\"children\":\"不同的\"}],\" 函数，因此 React 还必须重新渲染树中调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext(AuthContext)\"}],\" 的所有组件。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在较小的应用程序中，这不是问题。但是，如果基础数据如 \",[\"$r\",\"code\",null,{\"children\":\"currentUser\"}],\" 没有更改，则不需要重新渲染它们。为了帮助 React 利用这一点，你可以使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useCallback\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useCallback\"}]}],\" 包装 \",[\"$r\",\"code\",null,{\"children\":\"login\"}],\" 函数，并将对象创建包装到 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\" 中。这是一个性能优化的例子：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6,9,11,14,17}\",\"children\":\"import { useCallback, useMemo } from 'react';\\r\\n\\r\\nfunction MyApp() {\\r\\n  const [currentUser, setCurrentUser] = useState(null);\\r\\n\\r\\n  const login = useCallback((response) => {\\r\\n    storeCredentials(response.credentials);\\r\\n    setCurrentUser(response.user);\\r\\n  }, []);\\r\\n\\r\\n  const contextValue = useMemo(() => ({\\r\\n    currentUser,\\r\\n    login\\r\\n  }), [currentUser, login]);\\r\\n\\r\\n  return (\\r\\n    <AuthContext.Provider value={contextValue}>\\r\\n      <Page />\\r\\n    </AuthContext.Provider>\\r\\n  );\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"根据以上改变，即使 \",[\"$r\",\"code\",null,{\"children\":\"MyApp\"}],\" 需要重新渲染，调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext(AuthContext)\"}],\" 的组件也不需要重新渲染，除非 \",[\"$r\",\"code\",null,{\"children\":\"currentUser\"}],\" 发生了变化。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读更多关于 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useMemo#skipping-re-rendering-of-components\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useMemo\"}]}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useCallback#skipping-re-rendering-of-components\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useCallback\"}]}],\" 的内容。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"疑难解答 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"my-component-doesnt-see-the-value-from-my-provider\",\"children\":\"我的组件获取不到 provider 传递的值\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这里有几种常见的情况会引起这个问题：\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你在调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 的同一组件（或下层）渲染 \",[\"$r\",\"code\",null,{\"children\":\"<SomeContext.Provider>\"}],\"。把 \",[\"$r\",\"code\",null,{\"children\":\"<SomeContext.Provider>\"}],\" 向调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext()\"}],\" 组件 \",[\"$r\",\"strong\",null,{\"children\":\"之上和之外\"}],\" 移动。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你可能忘记了使用 \",[\"$r\",\"code\",null,{\"children\":\"<SomeContext.Provider>\"}],\" 包装组件，或者你可能将组件放在树的不同部分。使用 \",[\"$r\",\"a\",null,{\"href\":\"/learn/react-developer-tools\",\"children\":\"React DevTools\"}],\" 检查组件树的层级是否正确。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你的工具可能会遇到一些构建问题，导致你在传值组件中的所看到的 \",[\"$r\",\"code\",null,{\"children\":\"SomeContext\"}],\" 和读值组件中所看到的 \",[\"$r\",\"code\",null,{\"children\":\"SomeContext\"}],\" 是两个不同的对象。例如，如果使用符号链接，就会发生这种情况。你可以通过将它们赋值给全局对象如 \",[\"$r\",\"code\",null,{\"children\":\"window.SomeContext1\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"window.SomeContext2\"}],\" 来验证这种情况。然后在控制台检查 \",[\"$r\",\"code\",null,{\"children\":\"window.SomeContext1 === window.SomeContext2\"}],\" 是否相等。如果它们是不相等的，就在构建工具层面修复这个问题。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different\",\"children\":[\"尽管设置了不一样的默认值，但是我总是从 context 中得到 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可能在组件树中有一个没有设置 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\" 的 provider：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,2}\",\"children\":\"// 🚩 不起作用：没有 value 作为 prop\\r\\n<ThemeContext.Provider>\\r\\n   <Button />\\r\\n</ThemeContext.Provider>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你忘记了指定 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\"，它会像这样传值 \",[\"$r\",\"code\",null,{\"children\":\"value={undefined}\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可能还错误地使用了一个不同的 prop 名：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,2}\",\"children\":\"// 🚩 不起作用：prop 应该是“value”\\r\\n<ThemeContext.Provider theme={theme}>\\r\\n   <Button />\\r\\n</ThemeContext.Provider>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这两种情况下，你都应该在控制台中看到 React 发出的警告。要解决这些问题，使用 \",[\"$r\",\"code\",null,{\"children\":\"value\"}],\" 作为 prop：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1,2}\",\"children\":\"// ✅ 传递 value 作为 prop\\r\\n<ThemeContext.Provider value={theme}>\\r\\n   <Button />\\r\\n</ThemeContext.Provider>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"注意，只有在 \",[\"$r\",\"strong\",null,{\"children\":\"上层根本没有匹配的 provider\"}],\" 时才使用 \",[\"$r\",\"a\",null,{\"href\":\"#specifying-a-fallback-default-value\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"createContext(defaultValue)\"}],\"调用的默认值\"]}],\"。如果存在 \",[\"$r\",\"code\",null,{\"children\":\"<SomeContext.Provider value={undefined}>\"}],\" 组件在父树的某个位置，调用 \",[\"$r\",\"code\",null,{\"children\":\"useContext(SomeContext)\"}],\" 的组件 \",[\"$r\",\"strong\",null,{\"children\":\"将会\"}],\" 接收到 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" 作为 context 的值。\"]}]]}]]","toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#usecontext\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useContext(SomeContext)\"}],\" \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#passing-data-deeply-into-the-tree\",\"depth\":3,\"text\":\"向组件树深层传递数据 \"},{\"url\":\"#updating-data-passed-via-context\",\"depth\":3,\"text\":\"通过 context 更新传递的数据 \"},{\"url\":\"#specifying-a-fallback-default-value\",\"depth\":3,\"text\":\"指定后备方案默认值 \"},{\"url\":\"#overriding-context-for-a-part-of-the-tree\",\"depth\":3,\"text\":\"覆盖组件树一部分的 context \"},{\"url\":\"#optimizing-re-renders-when-passing-objects-and-functions\",\"depth\":3,\"text\":\"在传递对象和函数时优化重新渲染 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"疑难解答 \"},{\"url\":\"#my-component-doesnt-see-the-value-from-my-provider\",\"depth\":3,\"text\":\"我的组件获取不到 provider 传递的值\"},{\"url\":\"#i-am-always-getting-undefined-from-my-context-although-the-default-value-is-different\",\"depth\":3,\"text\":[\"尽管设置了不一样的默认值，但是我总是从 context 中得到 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]}]","meta":{"title":"useContext"}},"__N_SSG":true}