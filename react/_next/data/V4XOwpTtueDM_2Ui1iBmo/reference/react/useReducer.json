{"pageProps":{"content":"[[\"$r\",\"MaxWidth\",\"72\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 是一个 React Hook，它允许你向组件里面添加一个 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"reducer\"}],\"。\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [state, dispatch] = useReducer(reducer, initialArg, init?)\\n\"}]}]]}],\"\\n\",[\"$r\",\"InlineToc\",null,{}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reference\",\"children\":\"参考 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"usereducer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer(reducer, initialArg, init?)\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件的顶层作用域调用 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 以创建一个用于管理状态的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"reducer\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useReducer } from 'react';\\r\\n\\r\\nfunction reducer(state, action) {\\r\\n  // ...\\r\\n}\\r\\n\\r\\nfunction MyComponent() {\\r\\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\\r\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#usage\",\"children\":\"参见下方更多示例\"}],\"。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"reducer\"}],\"：用于更新 state 的纯函数。参数为 state 和 action，返回值是更新后的 state。state 与 action 可以是任意合法值。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"initialArg\"}],\"：用于初始化 state 的任意值。初始值的计算逻辑取决于接下来的 \",[\"$r\",\"code\",null,{\"children\":\"init\"}],\" 参数。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"可选参数\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"init\"}],\"：用于计算初始值的函数。如果存在，使用 \",[\"$r\",\"code\",null,{\"children\":\"init(initialArg)\"}],\" 的执行结果作为初始值，否则使用 \",[\"$r\",\"code\",null,{\"children\":\"initialArg\"}],\"。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 返回一个由两个值组成的数组：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"当前的 state。初次渲染时，它是 \",[\"$r\",\"code\",null,{\"children\":\"init(initialArg)\"}],\" 或 \",[\"$r\",\"code\",null,{\"children\":\"initialArg\"}],\" （如果没有 \",[\"$r\",\"code\",null,{\"children\":\"init\"}],\" 函数）。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"#dispatch\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数\"]}],\"。用于更新 state 并触发组件的重新渲染。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"caveats\",\"children\":\"注意事项 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 是一个 Hook，所以只能在 \",[\"$r\",\"strong\",null,{\"children\":\"组件的顶层作用域\"}],\" 或自定义 Hook 中调用，而不能在循环或条件语句中调用。如果你有这种需求，可以创建一个新的组件，并把 state 移入其中。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"严格模式下 React 会 \",[\"$r\",\"strong\",null,{\"children\":\"调用两次 reducer 和初始化函数\"}],\"，这可以 \",[\"$r\",\"a\",null,{\"href\":\"#my-reducer-or-initializer-function-runs-twice\",\"children\":\"帮助你发现意外的副作用\"}],\"。这只是开发模式下的行为，并不会影响生产环境。只要 reducer 和初始化函数是纯函数（理应如此）就不会改变你的逻辑。其中一个调用结果会被忽略。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"dispatch\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数 \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 返回的 \",[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数允许你更新 state 并触发组件的重新渲染。它需要传入一个 action 作为参数：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [state, dispatch] = useReducer(reducer, { age: 42 });\\r\\n\\r\\nfunction handleClick() {\\r\\n  dispatch({ type: 'incremented_age' });\\r\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 会调用 \",[\"$r\",\"code\",null,{\"children\":\"reducer\"}],\" 函数以更新 state，\",[\"$r\",\"code\",null,{\"children\":\"reducer\"}],\" 函数的参数为当前的 state 与传递的 action。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"dispatch-parameters\",\"children\":\"参数 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"action\"}],\"：用户执行的操作。可以是任意类型的值。通常来说 action 是一个对象，其中 \",[\"$r\",\"code\",null,{\"children\":\"type\"}],\" 属性标识类型，其它属性携带额外信息。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"dispatch-returns\",\"children\":\"返回值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数没有返回值。\"]}],\"\\n\",[\"$r\",\"h4\",null,{\"id\":\"setstate-caveats\",\"children\":\"注意 \"}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数 \",[\"$r\",\"strong\",null,{\"children\":\"是为下一次渲染而更新 state\"}],\"。因此在调用 \",[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数后读取 state \",[\"$r\",\"a\",null,{\"href\":\"#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value\",\"children\":\"并不会拿到更新后的值\"}],\"，也就是说只能获取到调用前的值。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你提供的新值与当前的 \",[\"$r\",\"code\",null,{\"children\":\"state\"}],\" 相同（使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 比较），React 会 \",[\"$r\",\"strong\",null,{\"children\":\"跳过组件和子组件的重新渲染\"}],\"，这是一种优化手段。虽然在跳过重新渲染前 React 可能会调用你的组件，但是这不应该影响你的代码。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React \",[\"$r\",\"a\",null,{\"href\":\"/learn/queueing-a-series-of-state-updates\",\"children\":\"会批量更新 state\"}],\"。state 会在 \",[\"$r\",\"strong\",null,{\"children\":\"所有事件函数执行完毕\"}],\" 并且已经调用过它的 \",[\"$r\",\"code\",null,{\"children\":\"set\"}],\" 函数后进行更新，这可以防止在一个事件中多次进行重新渲染。如果在访问 DOM 等极少数情况下需要强制 React 提前更新，可以使用 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react-dom/flushSync\",\"children\":[\"$r\",\"code\",null,{\"children\":\"flushSync\"}]}],\"。\"]}],\"\\n\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"usage\",\"children\":\"用法 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"adding-a-reducer-to-a-component\",\"children\":\"向组件添加 reducer \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在组件的顶层作用域调用 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 来创建一个用于管理状态（state）的 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"reducer\"}],\"。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[1, 8, \\\"state\\\"], [2, 8, \\\"dispatch\\\"], [4, 8, \\\"reducer\\\"], [3, 8, \\\"{ age: 42 }\\\"]]\",\"children\":\"import { useReducer } from 'react';\\r\\n\\r\\nfunction reducer(state, action) {\\r\\n  // ...\\r\\n}\\r\\n\\r\\nfunction MyComponent() {\\r\\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\\r\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 返回一个由两个值组成的数组：\"]}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":1,\"children\":\"当前的 state\"}],\"，首次渲染时为你提供的 \",[\"$r\",\"CodeStep\",null,{\"step\":3,\"children\":\"初始值\"}],\"。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数\"]}],\"，让你可以根据交互修改 state。\"]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"为了更新屏幕上的内容，使用一个表示用户操作的 action 来调用 \",[\"$r\",\"CodeStep\",null,{\"step\":2,\"children\":[\"$r\",\"code\",null,{\"children\":\"dispatch\"}]}],\" 函数：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"[[2, 2, \\\"dispatch\\\"]]\",\"children\":\"function handleClick() {\\r\\n  dispatch({ type: 'incremented_age' });\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 会把当前的 state 和这个 action 一起作为参数传给 \",[\"$r\",\"CodeStep\",null,{\"step\":4,\"children\":\"reducer 函数\"}],\"，然后 reducer 计算并返回新的 state，最后 React 保存新的 state，并使用它渲染组件和更新 UI。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useReducer } from 'react';\\r\\n\\r\\nfunction reducer(state, action) {\\r\\n  if (action.type === 'incremented_age') {\\r\\n    return {\\r\\n      age: state.age + 1\\r\\n    };\\r\\n  }\\r\\n  throw Error('Unknown action.');\\r\\n}\\r\\n\\r\\nexport default function Counter() {\\r\\n  const [state, dispatch] = useReducer(reducer, { age: 42 });\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <button onClick={() => {\\r\\n        dispatch({ type: 'incremented_age' })\\r\\n      }}>\\r\\n        Increment age\\r\\n      </button>\\r\\n      <p>Hello! You are {state.age}.</p>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"98\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/useState\",\"children\":[\"$r\",\"code\",null,{\"children\":\"useState\"}]}],\" 非常相似，但是它可以让你把状态更新逻辑从事件处理函数中移动到组件外部。详情可以参阅 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer#comparing-usestate-and-usereducer\",\"children\":[\"对比 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}]]}],\"。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"writing-the-reducer-function\",\"children\":\"实现 reducer 函数 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"reducer 函数的定义如下：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function reducer(state, action) {\\r\\n  // ...\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你需要往函数体里面添加计算并返回新的 state 的逻辑。一般会使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/switch\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[[\"$r\",\"code\",null,{\"children\":\"switch\"}],\" 语句\"]}],\" 来完成。在 \",[\"$r\",\"code\",null,{\"children\":\"switch\"}],\" 语句中通过匹配 \",[\"$r\",\"code\",null,{\"children\":\"case\"}],\" 条件来计算并返回相应的 state。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-7,10-13}\",\"children\":\"function reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'incremented_age': {\\r\\n      return {\\r\\n        name: state.name,\\r\\n        age: state.age + 1\\r\\n      };\\r\\n    }\\r\\n    case 'changed_name': {\\r\\n      return {\\r\\n        name: action.nextName,\\r\\n        age: state.age\\r\\n      };\\r\\n    }\\r\\n  }\\r\\n  throw Error('Unknown action: ' + action.type);\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"action 可以是任意类型，不过通常至少是一个存在 \",[\"$r\",\"code\",null,{\"children\":\"type\"}],\" 属性的对象。也就是说它需要携带计算新的 state 值所必须的数据。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5,9-12}\",\"children\":\"function Form() {\\r\\n  const [state, dispatch] = useReducer(reducer, { name: 'Taylor', age: 42 });\\r\\n  \\r\\n  function handleButtonClick() {\\r\\n    dispatch({ type: 'incremented_age' });\\r\\n  }\\r\\n\\r\\n  function handleInputChange(e) {\\r\\n    dispatch({\\r\\n      type: 'changed_name',\\r\\n      nextName: e.target.value\\r\\n    });\\r\\n  }\\r\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"action 的 type 依赖于组件的实际情况。\",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer#writing-reducers-well\",\"children\":\"即使它会导致数据的多次更新，每个 action 都只描述一次交互\"}],\"。state 的类型也是任意的，不过一般会使用对象或数组。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"迁移状态逻辑至 Reducer 中\"}],\" 来了解更多内容。\"]}],\"\\n\",[\"$r\",\"Pitfall\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"state 是只读的。即使是对象或数组也不要尝试修改它：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4,5}\",\"children\":\"function reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'incremented_age': {\\r\\n      // 🚩 不要像下面这样修改一个对象类型的 state：\\r\\n      state.age = state.age + 1;\\r\\n      return state;\\r\\n    }\\n\"}]}],[\"$r\",\"p\",null,{\"children\":\"正确的做法是返回新的对象：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-8}\",\"children\":\"function reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'incremented_age': {\\r\\n      // ✅ 正确的做法是返回新的对象\\r\\n      return {\\r\\n        ...state,\\r\\n        age: state.age + 1\\r\\n      };\\r\\n    }\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-objects-in-state\",\"children\":\"更新对象类型的 state\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-arrays-in-state\",\"children\":\"更新数组类型的 state\"}],\" 来了解更多内容。\"]}]]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"useReducer 的基础示例\",\"titleId\":\"examples-basic\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"form-object\",\"children\":\"表单（对象类型） \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个示例中，state 是一个有 \",[\"$r\",\"code\",null,{\"children\":\"name\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"age\"}],\" 属性的对象。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useReducer } from 'react';\\r\\n\\r\\nfunction reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'incremented_age': {\\r\\n      return {\\r\\n        name: state.name,\\r\\n        age: state.age + 1\\r\\n      };\\r\\n    }\\r\\n    case 'changed_name': {\\r\\n      return {\\r\\n        name: action.nextName,\\r\\n        age: state.age\\r\\n      };\\r\\n    }\\r\\n  }\\r\\n  throw Error('Unknown action: ' + action.type);\\r\\n}\\r\\n\\r\\nconst initialState = { name: 'Taylor', age: 42 };\\r\\n\\r\\nexport default function Form() {\\r\\n  const [state, dispatch] = useReducer(reducer, initialState);\\r\\n\\r\\n  function handleButtonClick() {\\r\\n    dispatch({ type: 'incremented_age' });\\r\\n  }\\r\\n\\r\\n  function handleInputChange(e) {\\r\\n    dispatch({\\r\\n      type: 'changed_name',\\r\\n      nextName: e.target.value\\r\\n    }); \\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <input\\r\\n        value={state.name}\\r\\n        onChange={handleInputChange}\\r\\n      />\\r\\n      <button onClick={handleButtonClick}>\\r\\n        Increment age\\r\\n      </button>\\r\\n      <p>Hello, {state.name}. You are {state.age}.</p>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { display: block; margin-top: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"todo-list-array\",\"children\":\"代办事项（数组类型） \"}],[\"$r\",\"p\",null,{\"children\":[\"在这个示例中，reducer 管理一个名为 tasks 的数组。数组 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-arrays-in-state\",\"children\":\"不能使用修改方法\"}],\" 来更新。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useReducer } from 'react';\\r\\nimport AddTask from './AddTask.js';\\r\\nimport TaskList from './TaskList.js';\\r\\n\\r\\nfunction tasksReducer(tasks, action) {\\r\\n  switch (action.type) {\\r\\n    case 'added': {\\r\\n      return [...tasks, {\\r\\n        id: action.id,\\r\\n        text: action.text,\\r\\n        done: false\\r\\n      }];\\r\\n    }\\r\\n    case 'changed': {\\r\\n      return tasks.map(t => {\\r\\n        if (t.id === action.task.id) {\\r\\n          return action.task;\\r\\n        } else {\\r\\n          return t;\\r\\n        }\\r\\n      });\\r\\n    }\\r\\n    case 'deleted': {\\r\\n      return tasks.filter(t => t.id !== action.id);\\r\\n    }\\r\\n    default: {\\r\\n      throw Error('Unknown action: ' + action.type);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nexport default function TaskApp() {\\r\\n  const [tasks, dispatch] = useReducer(\\r\\n    tasksReducer,\\r\\n    initialTasks\\r\\n  );\\r\\n\\r\\n  function handleAddTask(text) {\\r\\n    dispatch({\\r\\n      type: 'added',\\r\\n      id: nextId++,\\r\\n      text: text,\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleChangeTask(task) {\\r\\n    dispatch({\\r\\n      type: 'changed',\\r\\n      task: task\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleDeleteTask(taskId) {\\r\\n    dispatch({\\r\\n      type: 'deleted',\\r\\n      id: taskId\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <h1>Prague itinerary</h1>\\r\\n      <AddTask\\r\\n        onAddTask={handleAddTask}\\r\\n      />\\r\\n      <TaskList\\r\\n        tasks={tasks}\\r\\n        onChangeTask={handleChangeTask}\\r\\n        onDeleteTask={handleDeleteTask}\\r\\n      />\\r\\n    </>\\r\\n  );\\r\\n}\\r\\n\\r\\nlet nextId = 3;\\r\\nconst initialTasks = [\\r\\n  { id: 0, text: 'Visit Kafka Museum', done: true },\\r\\n  { id: 1, text: 'Watch a puppet show', done: false },\\r\\n  { id: 2, text: 'Lennon Wall pic', done: false }\\r\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTask.js hidden\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function AddTask({ onAddTask }) {\\r\\n  const [text, setText] = useState('');\\r\\n  return (\\r\\n    <>\\r\\n      <input\\r\\n        placeholder=\\\"Add task\\\"\\r\\n        value={text}\\r\\n        onChange={e => setText(e.target.value)}\\r\\n      />\\r\\n      <button onClick={() => {\\r\\n        setText('');\\r\\n        onAddTask(text);\\r\\n      }}>Add</button>\\r\\n    </>\\r\\n  )\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js hidden\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function TaskList({\\r\\n  tasks,\\r\\n  onChangeTask,\\r\\n  onDeleteTask\\r\\n}) {\\r\\n  return (\\r\\n    <ul>\\r\\n      {tasks.map(task => (\\r\\n        <li key={task.id}>\\r\\n          <Task\\r\\n            task={task}\\r\\n            onChange={onChangeTask}\\r\\n            onDelete={onDeleteTask}\\r\\n          />\\r\\n        </li>\\r\\n      ))}\\r\\n    </ul>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Task({ task, onChange, onDelete }) {\\r\\n  const [isEditing, setIsEditing] = useState(false);\\r\\n  let taskContent;\\r\\n  if (isEditing) {\\r\\n    taskContent = (\\r\\n      <>\\r\\n        <input\\r\\n          value={task.text}\\r\\n          onChange={e => {\\r\\n            onChange({\\r\\n              ...task,\\r\\n              text: e.target.value\\r\\n            });\\r\\n          }} />\\r\\n        <button onClick={() => setIsEditing(false)}>\\r\\n          Save\\r\\n        </button>\\r\\n      </>\\r\\n    );\\r\\n  } else {\\r\\n    taskContent = (\\r\\n      <>\\r\\n        {task.text}\\r\\n        <button onClick={() => setIsEditing(true)}>\\r\\n          Edit\\r\\n        </button>\\r\\n      </>\\r\\n    );\\r\\n  }\\r\\n  return (\\r\\n    <label>\\r\\n      <input\\r\\n        type=\\\"checkbox\\\"\\r\\n        checked={task.done}\\r\\n        onChange={e => {\\r\\n          onChange({\\r\\n            ...task,\\r\\n            done: e.target.checked\\r\\n          });\\r\\n        }}\\r\\n      />\\r\\n      {taskContent}\\r\\n      <button onClick={() => onDelete(task.id)}>\\r\\n        Delete\\r\\n      </button>\\r\\n    </label>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\r\\nli { list-style-type: none; }\\r\\nul, li { margin: 0; padding: 0; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"writing-concise-update-logic-with-immer\",\"children\":\"使用 Immer 编写简洁的更新逻辑 \"}],[\"$r\",\"p\",null,{\"children\":[\"如果使用复制方法更新数组和对象让你不厌其烦，那么可以使用 \",[\"$r\",\"a\",null,{\"href\":\"https://github.com/immerjs/use-immer#useimmerreducer\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Immer\"}],\" 这样的库来减少一些重复的样板代码。Immer 让你可以专注于逻辑，因为它在内部均使用复制方法来完成更新：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useImmerReducer } from 'use-immer';\\r\\nimport AddTask from './AddTask.js';\\r\\nimport TaskList from './TaskList.js';\\r\\n\\r\\nfunction tasksReducer(draft, action) {\\r\\n  switch (action.type) {\\r\\n    case 'added': {\\r\\n      draft.push({\\r\\n        id: action.id,\\r\\n        text: action.text,\\r\\n        done: false\\r\\n      });\\r\\n      break;\\r\\n    }\\r\\n    case 'changed': {\\r\\n      const index = draft.findIndex(t =>\\r\\n        t.id === action.task.id\\r\\n      );\\r\\n      draft[index] = action.task;\\r\\n      break;\\r\\n    }\\r\\n    case 'deleted': {\\r\\n      return draft.filter(t => t.id !== action.id);\\r\\n    }\\r\\n    default: {\\r\\n      throw Error('Unknown action: ' + action.type);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nexport default function TaskApp() {\\r\\n  const [tasks, dispatch] = useImmerReducer(\\r\\n    tasksReducer,\\r\\n    initialTasks\\r\\n  );\\r\\n\\r\\n  function handleAddTask(text) {\\r\\n    dispatch({\\r\\n      type: 'added',\\r\\n      id: nextId++,\\r\\n      text: text,\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleChangeTask(task) {\\r\\n    dispatch({\\r\\n      type: 'changed',\\r\\n      task: task\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleDeleteTask(taskId) {\\r\\n    dispatch({\\r\\n      type: 'deleted',\\r\\n      id: taskId\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <h1>Prague itinerary</h1>\\r\\n      <AddTask\\r\\n        onAddTask={handleAddTask}\\r\\n      />\\r\\n      <TaskList\\r\\n        tasks={tasks}\\r\\n        onChangeTask={handleChangeTask}\\r\\n        onDeleteTask={handleDeleteTask}\\r\\n      />\\r\\n    </>\\r\\n  );\\r\\n}\\r\\n\\r\\nlet nextId = 3;\\r\\nconst initialTasks = [\\r\\n  { id: 0, text: 'Visit Kafka Museum', done: true },\\r\\n  { id: 1, text: 'Watch a puppet show', done: false },\\r\\n  { id: 2, text: 'Lennon Wall pic', done: false },\\r\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTask.js hidden\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function AddTask({ onAddTask }) {\\r\\n  const [text, setText] = useState('');\\r\\n  return (\\r\\n    <>\\r\\n      <input\\r\\n        placeholder=\\\"Add task\\\"\\r\\n        value={text}\\r\\n        onChange={e => setText(e.target.value)}\\r\\n      />\\r\\n      <button onClick={() => {\\r\\n        setText('');\\r\\n        onAddTask(text);\\r\\n      }}>Add</button>\\r\\n    </>\\r\\n  )\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js hidden\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function TaskList({\\r\\n  tasks,\\r\\n  onChangeTask,\\r\\n  onDeleteTask\\r\\n}) {\\r\\n  return (\\r\\n    <ul>\\r\\n      {tasks.map(task => (\\r\\n        <li key={task.id}>\\r\\n          <Task\\r\\n            task={task}\\r\\n            onChange={onChangeTask}\\r\\n            onDelete={onDeleteTask}\\r\\n          />\\r\\n        </li>\\r\\n      ))}\\r\\n    </ul>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Task({ task, onChange, onDelete }) {\\r\\n  const [isEditing, setIsEditing] = useState(false);\\r\\n  let taskContent;\\r\\n  if (isEditing) {\\r\\n    taskContent = (\\r\\n      <>\\r\\n        <input\\r\\n          value={task.text}\\r\\n          onChange={e => {\\r\\n            onChange({\\r\\n              ...task,\\r\\n              text: e.target.value\\r\\n            });\\r\\n          }} />\\r\\n        <button onClick={() => setIsEditing(false)}>\\r\\n          Save\\r\\n        </button>\\r\\n      </>\\r\\n    );\\r\\n  } else {\\r\\n    taskContent = (\\r\\n      <>\\r\\n        {task.text}\\r\\n        <button onClick={() => setIsEditing(true)}>\\r\\n          Edit\\r\\n        </button>\\r\\n      </>\\r\\n    );\\r\\n  }\\r\\n  return (\\r\\n    <label>\\r\\n      <input\\r\\n        type=\\\"checkbox\\\"\\r\\n        checked={task.done}\\r\\n        onChange={e => {\\r\\n          onChange({\\r\\n            ...task,\\r\\n            done: e.target.checked\\r\\n          });\\r\\n        }}\\r\\n      />\\r\\n      {taskContent}\\r\\n      <button onClick={() => onDelete(task.id)}>\\r\\n        Delete\\r\\n      </button>\\r\\n    </label>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\r\\nli { list-style-type: none; }\\r\\nul, li { margin: 0; padding: 0; }\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json\",\"children\":\"{\\r\\n  \\\"dependencies\\\": {\\r\\n    \\\"immer\\\": \\\"1.7.3\\\",\\r\\n    \\\"react\\\": \\\"latest\\\",\\r\\n    \\\"react-dom\\\": \\\"latest\\\",\\r\\n    \\\"react-scripts\\\": \\\"latest\\\",\\r\\n    \\\"use-immer\\\": \\\"0.5.1\\\"\\r\\n  },\\r\\n  \\\"scripts\\\": {\\r\\n    \\\"start\\\": \\\"react-scripts start\\\",\\r\\n    \\\"build\\\": \\\"react-scripts build\\\",\\r\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\r\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\r\\n  }\\r\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"118\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"avoiding-recreating-the-initial-state\",\"children\":\"避免重新创建初始值 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"React 会保存 state 的初始值并在下一次渲染时忽略它。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"function createInitialState(username) {\\r\\n  // ...\\r\\n}\\r\\n\\r\\nfunction TodoList({ username }) {\\r\\n  const [state, dispatch] = useReducer(reducer, createInitialState(username));\\r\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"虽然 \",[\"$r\",\"code\",null,{\"children\":\"createInitialState(username)\"}],\" 的返回值只用于初次渲染，但是在每一次渲染的时候都会被调用。如果它创建了比较大的数组或者执行了昂贵的计算就会浪费性能。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以通过给  \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 的第三个参数传入 \",[\"$r\",\"strong\",null,{\"children\":\"初始化函数\"}],\" 来解决这个问题：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{6}\",\"children\":\"function createInitialState(username) {\\r\\n  // ...\\r\\n}\\r\\n\\r\\nfunction TodoList({ username }) {\\r\\n  const [state, dispatch] = useReducer(reducer, username, createInitialState);\\r\\n  // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"需要注意的是你传入的参数是 \",[\"$r\",\"code\",null,{\"children\":\"createInitialState\"}],\" 这个 \",[\"$r\",\"strong\",null,{\"children\":\"函数自身\"}],\"，而不是执行 \",[\"$r\",\"code\",null,{\"children\":\"createInitialState()\"}],\" 后的返回值。这样传参就可以保证初始化函数不会再次运行。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在上面这个例子中，\",[\"$r\",\"code\",null,{\"children\":\"createInitialState\"}],\" 有一个 \",[\"$r\",\"code\",null,{\"children\":\"username\"}],\" 参数。如果初始化函数不需要参数就可以计算出初始值，可以把 \",[\"$r\",\"code\",null,{\"children\":\"useReducer\"}],\" 的第二个参数改为 \",[\"$r\",\"code\",null,{\"children\":\"null\"}],\"。\"]}],\"\\n\"]}],[\"$r\",\"Recipes\",null,{\"titleText\":\"使用初始化函数和直接传入初始值的区别\",\"titleId\":\"examples-initializer\",\"children\":[[\"$r\",\"h4\",null,{\"id\":\"passing-the-initializer-function\",\"children\":\"使用初始化函数 \"}],[\"$r\",\"p\",null,{\"children\":[\"这个示例使用了一个初始化函数，所以 \",[\"$r\",\"code\",null,{\"children\":\"createInitialState\"}],\" 函数只会在初次渲染的时候进行调用。即使往输入框中输入内容导致组件重新渲染，初始化函数也不会被再次调用。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import TodoList from './TodoList.js';\\r\\n\\r\\nexport default function App() {\\r\\n  return <TodoList username=\\\"Taylor\\\" />;\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TodoList.js active\",\"children\":\"import { useReducer } from 'react';\\r\\n\\r\\nfunction createInitialState(username) {\\r\\n  const initialTodos = [];\\r\\n  for (let i = 0; i < 50; i++) {\\r\\n    initialTodos.push({\\r\\n      id: i,\\r\\n      text: username + \\\"'s task #\\\" + (i + 1)\\r\\n    });\\r\\n  }\\r\\n  return {\\r\\n    draft: '',\\r\\n    todos: initialTodos,\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'changed_draft': {\\r\\n      return {\\r\\n        draft: action.nextDraft,\\r\\n        todos: state.todos,\\r\\n      };\\r\\n    };\\r\\n    case 'added_todo': {\\r\\n      return {\\r\\n        draft: '',\\r\\n        todos: [{\\r\\n          id: state.todos.length,\\r\\n          text: state.draft\\r\\n        }, ...state.todos]\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  throw Error('Unknown action: ' + action.type);\\r\\n}\\r\\n\\r\\nexport default function TodoList({ username }) {\\r\\n  const [state, dispatch] = useReducer(\\r\\n    reducer,\\r\\n    username,\\r\\n    createInitialState\\r\\n  );\\r\\n  return (\\r\\n    <>\\r\\n      <input\\r\\n        value={state.draft}\\r\\n        onChange={e => {\\r\\n          dispatch({\\r\\n            type: 'changed_draft',\\r\\n            nextDraft: e.target.value\\r\\n          })\\r\\n        }}\\r\\n      />\\r\\n      <button onClick={() => {\\r\\n        dispatch({ type: 'added_todo' });\\r\\n      }}>Add</button>\\r\\n      <ul>\\r\\n        {state.todos.map(item => (\\r\\n          <li key={item.id}>\\r\\n            {item.text}\\r\\n          </li>\\r\\n        ))}\\r\\n      </ul>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}],[\"$r\",\"h4\",null,{\"id\":\"passing-the-initial-state-directly\",\"children\":\"直接传入初始值 \"}],[\"$r\",\"p\",null,{\"children\":[\"这个示例 \",[\"$r\",\"strong\",null,{\"children\":\"没有使用\"}],\" 初始化函数，所以当你往输入框输入内容导致组件重新渲染的时候，\",[\"$r\",\"code\",null,{\"children\":\"createInitialState\"}],\" 函数就会执行。虽然在渲染结果上看没有什么区别，但是多余的逻辑会导致性能变差。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js hidden\",\"children\":\"import TodoList from './TodoList.js';\\r\\n\\r\\nexport default function App() {\\r\\n  return <TodoList username=\\\"Taylor\\\" />;\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TodoList.js active\",\"children\":\"import { useReducer } from 'react';\\r\\n\\r\\nfunction createInitialState(username) {\\r\\n  const initialTodos = [];\\r\\n  for (let i = 0; i < 50; i++) {\\r\\n    initialTodos.push({\\r\\n      id: i,\\r\\n      text: username + \\\"'s task #\\\" + (i + 1)\\r\\n    });\\r\\n  }\\r\\n  return {\\r\\n    draft: '',\\r\\n    todos: initialTodos,\\r\\n  };\\r\\n}\\r\\n\\r\\nfunction reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'changed_draft': {\\r\\n      return {\\r\\n        draft: action.nextDraft,\\r\\n        todos: state.todos,\\r\\n      };\\r\\n    };\\r\\n    case 'added_todo': {\\r\\n      return {\\r\\n        draft: '',\\r\\n        todos: [{\\r\\n          id: state.todos.length,\\r\\n          text: state.draft\\r\\n        }, ...state.todos]\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n  throw Error('Unknown action: ' + action.type);\\r\\n}\\r\\n\\r\\nexport default function TodoList({ username }) {\\r\\n  const [state, dispatch] = useReducer(\\r\\n    reducer,\\r\\n    createInitialState(username)\\r\\n  );\\r\\n  return (\\r\\n    <>\\r\\n      <input\\r\\n        value={state.draft}\\r\\n        onChange={e => {\\r\\n          dispatch({\\r\\n            type: 'changed_draft',\\r\\n            nextDraft: e.target.value\\r\\n          })\\r\\n        }}\\r\\n      />\\r\\n      <button onClick={() => {\\r\\n        dispatch({ type: 'added_todo' });\\r\\n      }}>Add</button>\\r\\n      <ul>\\r\\n        {state.todos.map(item => (\\r\\n          <li key={item.id}>\\r\\n            {item.text}\\r\\n          </li>\\r\\n        ))}\\r\\n      </ul>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"troubleshooting\",\"children\":\"疑难解答 \"}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"ive-dispatched-an-action-but-logging-gives-me-the-old-state-value\",\"children\":\"我已经 dispatch 了一个 action，但是打印出来仍然还是旧的 state \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"调用 \",[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数 \",[\"$r\",\"strong\",null,{\"children\":\"不会改变当前渲染的 state\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4,5,8}\",\"children\":\"function handleClick() {\\r\\n  console.log(state.age);  // 42\\r\\n\\r\\n  dispatch({ type: 'incremented_age' }); // 用 43 进行重新渲染\\r\\n  console.log(state.age);  // 还是 42！\\r\\n\\r\\n  setTimeout(() => {\\r\\n    console.log(state.age); // 一样是 42！\\r\\n  }, 5000);\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这是因为 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot\",\"children\":\"state 的行为和快照一样\"}],\"。更新 state 会使用新的值来对组件进行重新渲染，但是不会改变当前执行的事件处理函数里面 \",[\"$r\",\"code\",null,{\"children\":\"state\"}],\" 的值。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"如果你需要获取更新后的 state，可以手动调用 reducer 来得到结果：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const action = { type: 'incremented_age' };\\r\\ndispatch(action);\\r\\n\\r\\nconst nextState = reducer(state, action);\\r\\nconsole.log(state);     // { age: 42 }\\r\\nconsole.log(nextState); // { age: 43 }\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"ive-dispatched-an-action-but-the-screen-doesnt-update\",\"children\":\"我已经 dispatch 了一个 action，但是屏幕并没有更新 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 使用 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/is\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":[\"$r\",\"code\",null,{\"children\":\"Object.is\"}]}],\" 比较更新前后的 state，如果 \",[\"$r\",\"strong\",null,{\"children\":\"它们相等就会跳过这次更新\"}],\"。这通常是因为你直接修改了对象或数组：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-5,9-10}\",\"children\":\"function reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'incremented_age': {\\r\\n      // 🚩 错误行为：直接修改对象\\r\\n      state.age++;\\r\\n      return state;\\r\\n    }\\r\\n    case 'changed_name': {\\r\\n      // 🚩 错误行为：直接修改对象\\r\\n      state.name = action.nextName;\\r\\n      return state;\\r\\n    }\\r\\n    // ...\\r\\n  }\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你直接修改并返回了一个 \",[\"$r\",\"code\",null,{\"children\":\"state\"}],\" 对象，所以 React 会跳过这次更新。为了修复这个错误，你应该确保总是 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-objects-in-state\",\"children\":\"使用正确的方式更新对象\"}],\" 和 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-arrays-in-state\",\"children\":\"使用正确的方式更新数组\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-8,11-15}\",\"children\":\"function reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'incremented_age': {\\r\\n      // ✅ 修复：创建一个新的对象\\r\\n      return {\\r\\n        ...state,\\r\\n        age: state.age + 1\\r\\n      };\\r\\n    }\\r\\n    case 'changed_name': {\\r\\n      // ✅ 修复：创建一个新的对象\\r\\n      return {\\r\\n        ...state,\\r\\n        name: action.nextName\\r\\n      };\\r\\n    }\\r\\n    // ...\\r\\n  }\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"a-part-of-my-reducer-state-becomes-undefined-after-dispatching\",\"children\":[\"在 dispatch 后 state 的某些属性变为了 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请确保每个 \",[\"$r\",\"code\",null,{\"children\":\"case\"}],\" 语句中所返回的新的 state \",[\"$r\",\"strong\",null,{\"children\":\"都复制了当前的属性\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{5}\",\"children\":\"function reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'incremented_age': {\\r\\n      return {\\r\\n        ...state, // 不要忘记复制之前的属性！\\r\\n        age: state.age + 1\\r\\n      };\\r\\n    }\\r\\n    // ...\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果上面的代码没有 \",[\"$r\",\"code\",null,{\"children\":\"...state\"}],\" ，返回的新的 state 就只有 \",[\"$r\",\"code\",null,{\"children\":\"age\"}],\" 属性。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"my-entire-reducer-state-becomes-undefined-after-dispatching\",\"children\":[\"在 dispatch 后整个 state 都变为了 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你的 state 错误地变成了 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\"，可能是因为你忘记在某个分支返回 state，或者是你遗漏了某些 \",[\"$r\",\"code\",null,{\"children\":\"case\"}],\" 分支。可以通过在 \",[\"$r\",\"code\",null,{\"children\":\"switch\"}],\" 语句之后抛出一个错误来查找原因：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{10}\",\"children\":\"function reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'incremented_age': {\\r\\n      // ...\\r\\n    }\\r\\n    case 'edited_name': {\\r\\n      // ...\\r\\n    }\\r\\n  }\\r\\n  throw Error('Unknown action: ' + action.type);\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"也可以通过使用 TypeScript 等静态检查工具来发现这类错误。\"}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"im-getting-an-error-too-many-re-renders\",\"children\":\"我收到了一个报错：“Too many re-renders” \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可能会收到这样一条报错信息：\",[\"$r\",\"code\",null,{\"children\":\"Too many re-renders. React limits the number of renders to prevent an infinite loop.\"}],\"。这通常是在 \",[\"$r\",\"strong\",null,{\"children\":\"渲染期间\"}],\"  dispatch 了 action 而导致组件进入了无限循环：dispatch（会导致一次重新渲染）、渲染、dispatch（再次导致重新渲染），然后无限循环。大多数这样的错误是由于事件处理函数中存在错误的逻辑：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{1-2}\",\"children\":\"// 🚩 错误：渲染期间调用了处理函数\\r\\nreturn <button onClick={handleClick()}>Click me</button>\\r\\n\\r\\n// ✅ 修复：传递一个处理函数，而不是调用\\r\\nreturn <button onClick={handleClick}>Click me</button>\\r\\n\\r\\n// ✅ 修复：传递一个内联的箭头函数\\r\\nreturn <button onClick={(e) => handleClick(e)}>Click me</button>\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你没有发现上述错误，在控制台点开报错旁边的箭头以查看错误堆栈，从中查找是哪个 \",[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数引发的错误。\"]}],\"\\n\",[\"$r\",\"hr\",null,{}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"my-reducer-or-initializer-function-runs-twice\",\"children\":\"我的 reducer 和初始化函数运行了两次 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[[\"$r\",\"a\",null,{\"href\":\"/reference/react/StrictMode\",\"children\":\"严格模式\"}],\" 下 React 会调用两次 reducer 和初始化函数，但是这不应该会破坏你的代码逻辑。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这个 \",[\"$r\",\"strong\",null,{\"children\":\"仅限于开发模式\"}],\" 的行为可以帮助你 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"保持组件纯粹\"}],\"：React 会使用其中一次调用结果并忽略另一个结果。如果你的组件、初始化函数以及 reducer 函数都是纯函数，这并不会影响你的逻辑。不过一旦它们存在副作用，这个额外的行为就可以帮助你发现它。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"比如下面这个 reducer 函数直接修改了数组类型的 state：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-6}\",\"children\":\"function reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'added_todo': {\\r\\n      // 🚩 错误：直接修改 state\\r\\n      state.todos.push({ id: nextId++, text: action.text });\\r\\n      return state;\\r\\n    }\\r\\n    // ...\\r\\n  }\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"因为 React 会调用 reducer 函数两次，导致你看到添加了两条代办事项，于是你就发现了这个错误行为。在这个示例中，你可以通过 \",[\"$r\",\"a\",null,{\"href\":\"/learn/updating-arrays-in-state#adding-to-an-array\",\"children\":\"返回新的数组而不是修改数组\"}],\" 来修复它：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"{4-11}\",\"children\":\"function reducer(state, action) {\\r\\n  switch (action.type) {\\r\\n    case 'added_todo': {\\r\\n      // ✅ 修复：返回一个新的 state 数组\\r\\n      return {\\r\\n        ...state,\\r\\n        todos: [\\r\\n          ...state.todos,\\r\\n          { id: nextId++, text: action.text }\\r\\n        ]\\r\\n      };\\r\\n    }\\r\\n    // ...\\r\\n  }\\r\\n}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"现在这个 reducer 是纯函数了，调用两次也不会有不一致的行为。这就是 React 如何通过调用两次函数来帮助你发现错误。\",[\"$r\",\"strong\",null,{\"children\":\"只有组件、初始化函数和 reducer 函数需要是纯函数\"}],\"。事件处理函数不需要实现为纯函数，并且 React 永远不会调用事件函数两次。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure\",\"children\":\"保持组件纯粹\"}],\" 以了解更多相关信息。\"]}]]}]]","toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reference\",\"depth\":2,\"text\":\"参考 \"},{\"url\":\"#usereducer\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"useReducer(reducer, initialArg, init?)\"}],\" \"]},{\"url\":\"#dispatch\",\"depth\":3,\"text\":[[\"$r\",\"code\",null,{\"children\":\"dispatch\"}],\" 函数 \"]},{\"url\":\"#usage\",\"depth\":2,\"text\":\"用法 \"},{\"url\":\"#adding-a-reducer-to-a-component\",\"depth\":3,\"text\":\"向组件添加 reducer \"},{\"url\":\"#writing-the-reducer-function\",\"depth\":3,\"text\":\"实现 reducer 函数 \"},{\"url\":\"#avoiding-recreating-the-initial-state\",\"depth\":3,\"text\":\"避免重新创建初始值 \"},{\"url\":\"#troubleshooting\",\"depth\":2,\"text\":\"疑难解答 \"},{\"url\":\"#ive-dispatched-an-action-but-logging-gives-me-the-old-state-value\",\"depth\":3,\"text\":\"我已经 dispatch 了一个 action，但是打印出来仍然还是旧的 state \"},{\"url\":\"#ive-dispatched-an-action-but-the-screen-doesnt-update\",\"depth\":3,\"text\":\"我已经 dispatch 了一个 action，但是屏幕并没有更新 \"},{\"url\":\"#a-part-of-my-reducer-state-becomes-undefined-after-dispatching\",\"depth\":3,\"text\":[\"在 dispatch 后 state 的某些属性变为了 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]},{\"url\":\"#my-entire-reducer-state-becomes-undefined-after-dispatching\",\"depth\":3,\"text\":[\"在 dispatch 后整个 state 都变为了 \",[\"$r\",\"code\",null,{\"children\":\"undefined\"}],\" \"]},{\"url\":\"#im-getting-an-error-too-many-re-renders\",\"depth\":3,\"text\":\"我收到了一个报错：“Too many re-renders” \"},{\"url\":\"#my-reducer-or-initializer-function-runs-twice\",\"depth\":3,\"text\":\"我的 reducer 和初始化函数运行了两次 \"}]","meta":{"title":"useReducer"}},"__N_SSG":true}