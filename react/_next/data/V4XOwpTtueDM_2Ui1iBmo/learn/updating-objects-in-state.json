{"pageProps":{"content":"[[\"$r\",\"MaxWidth\",\"32\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"state 中可以保存任意类型的 JavaScript 值，包括对象。但是，你不应该直接修改存放在 React state 中的对象。相反，当你想要更新一个对象时，你需要创建一个新的对象（或者将其拷贝一份），然后将 state 更新为此对象。\"}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何正确地更新 React state 中的对象\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何在不产生 mutation 的情况下更新一个嵌套对象\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"什么是不可变性（immutability），以及如何不破坏它\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"如何使用 Immer 使复制对象不那么繁琐\"}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"whats-a-mutation\",\"children\":\"什么是 mutation？ \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"你可以在 state 中存放任意类型的 JavaScript 值。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [x, setX] = useState(0);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"到目前为止，你已经尝试过在 state 中存放数字、字符串和布尔值，这些类型的值在 JavaScript 中是不可变（immutable）的，这意味着它们不能被改变或是只读的。你可以通过替换它们的值以触发一次重新渲染。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setX(5);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"state \",[\"$r\",\"code\",null,{\"children\":\"x\"}],\" 从 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\" 变为 \",[\"$r\",\"code\",null,{\"children\":\"5\"}],\"，但是数字 \",[\"$r\",\"code\",null,{\"children\":\"0\"}],\" 本身并没有发生改变。在 JavaScript 中，无法对内置的原始值，如数字、字符串和布尔值，进行任何更改。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在考虑 state 中存放对象的情况：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [position, setPosition] = useState({ x: 0, y: 0 });\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"从技术上来讲，可以改变对象自身的内容。\",[\"$r\",\"strong\",null,{\"children\":\"当你这样做时，就制造了一个 mutation\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"position.x = 5;\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"然而，虽然严格来说 React state 中存放的对象是可变的，但你应该像处理数字、布尔值、字符串一样将它们视为不可变的。因此你应该替换它们的值，而不是对它们进行修改。\"}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"treat-state-as-read-only\",\"children\":\"将 state 视为只读的 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"换句话说，你应该 \",[\"$r\",\"strong\",null,{\"children\":\"把所有存放在 state 中的 JavaScript 对象都视为只读的\"}],\"。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在下面的例子中，我们用一个存放在 state 中的对象来表示指针当前的位置。当你在预览区触摸或移动光标时，红色的点本应移动。但是实际上红点仍停留在原处：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\nexport default function MovingDot() {\\r\\n  const [position, setPosition] = useState({\\r\\n    x: 0,\\r\\n    y: 0\\r\\n  });\\r\\n  return (\\r\\n    <div\\r\\n      onPointerMove={e => {\\r\\n        position.x = e.clientX;\\r\\n        position.y = e.clientY;\\r\\n      }}\\r\\n      style={{\\r\\n        position: 'relative',\\r\\n        width: '100vw',\\r\\n        height: '100vh',\\r\\n      }}>\\r\\n      <div style={{\\r\\n        position: 'absolute',\\r\\n        backgroundColor: 'red',\\r\\n        borderRadius: '50%',\\r\\n        transform: `translate(${position.x}px, ${position.y}px)`,\\r\\n        left: -10,\\r\\n        top: -10,\\r\\n        width: 20,\\r\\n        height: 20,\\r\\n      }} />\\r\\n    </div>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { margin: 0; padding: 0; height: 250px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"50\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"问题出在下面这段代码中。\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"onPointerMove={e => {\\r\\n  position.x = e.clientX;\\r\\n  position.y = e.clientY;\\r\\n}}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这段代码直接修改了 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot#rendering-takes-a-snapshot-in-time\",\"children\":\"上一次渲染中\"}],\" 分配给 \",[\"$r\",\"code\",null,{\"children\":\"position\"}],\" 的对象。但是因为并没有使用 state 的设置函数，React 并不知道对象已更改。所以 React 没有做出任何响应。这就像在吃完饭之后才尝试去改变要点的菜一样。虽然在一些情况下，直接修改 state 可能是有效的，但我们并不推荐这么做。你应该把在渲染过程中可以访问到的 state 视为只读的。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在这种情况下，为了真正地 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot#setting-state-triggers-renders\",\"children\":\"触发一次重新渲染\"}],\"，\",[\"$r\",\"strong\",null,{\"children\":\"你需要创建一个新对象并把它传递给 state 的设置函数\"}],\"：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"onPointerMove={e => {\\r\\n  setPosition({\\r\\n    x: e.clientX,\\r\\n    y: e.clientY\\r\\n  });\\r\\n}}\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"通过使用 \",[\"$r\",\"code\",null,{\"children\":\"setPosition\"}],\"，你在告诉 React：\"]}],\"\\n\",[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"使用这个新的对象替换 \",[\"$r\",\"code\",null,{\"children\":\"position\"}],\" 的值\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"然后再次渲染这个组件\"}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在你可以看到，当你在预览区触摸或移动光标时，红点会跟随着你的指针移动：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\nexport default function MovingDot() {\\r\\n  const [position, setPosition] = useState({\\r\\n    x: 0,\\r\\n    y: 0\\r\\n  });\\r\\n  return (\\r\\n    <div\\r\\n      onPointerMove={e => {\\r\\n        setPosition({\\r\\n          x: e.clientX,\\r\\n          y: e.clientY\\r\\n        });\\r\\n      }}\\r\\n      style={{\\r\\n        position: 'relative',\\r\\n        width: '100vw',\\r\\n        height: '100vh',\\r\\n      }}>\\r\\n      <div style={{\\r\\n        position: 'absolute',\\r\\n        backgroundColor: 'red',\\r\\n        borderRadius: '50%',\\r\\n        transform: `translate(${position.x}px, ${position.y}px)`,\\r\\n        left: -10,\\r\\n        top: -10,\\r\\n        width: 20,\\r\\n        height: 20,\\r\\n      }} />\\r\\n    </div>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { margin: 0; padding: 0; height: 250px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"60\",{\"children\":[\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"local-mutation-is-fine\",\"children\":\"局部 mutation 是可以接受的 \"}],[\"$r\",\"p\",null,{\"children\":\"像这样的代码是有问题的，因为它改变了 state 中现有的对象：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"position.x = e.clientX;\\r\\nposition.y = e.clientY;\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"但是像这样的代码就 \",[\"$r\",\"strong\",null,{\"children\":\"没有任何问题\"}],\"，因为你改变的是你刚刚创建的一个新的对象：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const nextPosition = {};\\r\\nnextPosition.x = e.clientX;\\r\\nnextPosition.y = e.clientY;\\r\\nsetPosition(nextPosition);\\n\"}]}],[\"$r\",\"p\",null,{\"children\":\"事实上，它完全等同于下面这种写法：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setPosition({\\r\\n  x: e.clientX,\\r\\n  y: e.clientY\\r\\n});\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"只有当你改变已经处于 state 中的 \",[\"$r\",\"strong\",null,{\"children\":\"现有\"}],\" 对象时，mutation 才会成为问题。而修改一个你刚刚创建的对象就不会出现任何问题，因为 \",[\"$r\",\"strong\",null,{\"children\":\"还没有其他的代码引用它\"}],\"。改变它并不会意外地影响到依赖它的东西。这叫做“局部 mutation”。你甚至可以 \",[\"$r\",\"a\",null,{\"href\":\"/learn/keeping-components-pure#local-mutation-your-components-little-secret\",\"children\":\"在渲染的过程中\"}],\" 进行“局部 mutation”的操作。这种操作既便捷又没有任何问题！\"]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"copying-objects-with-the-spread-syntax\",\"children\":\"使用展开语法复制对象 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"在之前的例子中，始终会根据当前指针的位置创建出一个新的 \",[\"$r\",\"code\",null,{\"children\":\"position\"}],\" 对象。但是通常，你会希望把 \",[\"$r\",\"strong\",null,{\"children\":\"现有\"}],\" 数据作为你所创建的新对象的一部分。例如，你可能只想要更新表单中的一个字段，其他的字段仍然使用之前的值。\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"下面的代码中，输入框并不会正常运行，因为 \",[\"$r\",\"code\",null,{\"children\":\"onChange\"}],\" 直接修改了 state ：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Form() {\\r\\n  const [person, setPerson] = useState({\\r\\n    firstName: 'Barbara',\\r\\n    lastName: 'Hepworth',\\r\\n    email: 'bhepworth@sculpture.com'\\r\\n  });\\r\\n\\r\\n  function handleFirstNameChange(e) {\\r\\n    person.firstName = e.target.value;\\r\\n  }\\r\\n\\r\\n  function handleLastNameChange(e) {\\r\\n    person.lastName = e.target.value;\\r\\n  }\\r\\n\\r\\n  function handleEmailChange(e) {\\r\\n    person.email = e.target.value;\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <label>\\r\\n        First name:\\r\\n        <input\\r\\n          value={person.firstName}\\r\\n          onChange={handleFirstNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Last name:\\r\\n        <input\\r\\n          value={person.lastName}\\r\\n          onChange={handleLastNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Email:\\r\\n        <input\\r\\n          value={person.email}\\r\\n          onChange={handleEmailChange}\\r\\n        />\\r\\n      </label>\\r\\n      <p>\\r\\n        {person.firstName}{' '}\\r\\n        {person.lastName}{' '}\\r\\n        ({person.email})\\r\\n      </p>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\r\\ninput { margin-left: 5px; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"78\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"例如，下面这行代码修改了上一次渲染中的 state：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"person.firstName = e.target.value;\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"想要实现你的需求，最可靠的办法就是创建一个新的对象并将它传递给 \",[\"$r\",\"code\",null,{\"children\":\"setPerson\"}],\"。但是在这里，你还需要 \",[\"$r\",\"strong\",null,{\"children\":\"把当前的数据复制到新对象中\"}],\"，因为你只改变了其中一个字段：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setPerson({\\r\\n  firstName: e.target.value, // 从 input 中获取新的 first name\\r\\n  lastName: person.lastName,\\r\\n  email: person.email\\r\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以使用 \",[\"$r\",\"code\",null,{\"children\":\"...\"}],\" \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Spread_syntax#spread_in_object_literals\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"对象展开\"}],\" 语法，这样你就不需要单独复制每个属性。\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setPerson({\\r\\n  ...person, // 复制上一个 person 中的所有字段\\r\\n  firstName: e.target.value // 但是覆盖 firstName 字段 \\r\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"现在表单可以正常运行了！\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"可以看到，你并没有为每个输入框单独声明一个 state。对于大型表单，将所有数据都存放在同一个对象中是非常方便的——前提是你能够正确地更新它！\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Form() {\\r\\n  const [person, setPerson] = useState({\\r\\n    firstName: 'Barbara',\\r\\n    lastName: 'Hepworth',\\r\\n    email: 'bhepworth@sculpture.com'\\r\\n  });\\r\\n\\r\\n  function handleFirstNameChange(e) {\\r\\n    setPerson({\\r\\n      ...person,\\r\\n      firstName: e.target.value\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleLastNameChange(e) {\\r\\n    setPerson({\\r\\n      ...person,\\r\\n      lastName: e.target.value\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleEmailChange(e) {\\r\\n    setPerson({\\r\\n      ...person,\\r\\n      email: e.target.value\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <label>\\r\\n        First name:\\r\\n        <input\\r\\n          value={person.firstName}\\r\\n          onChange={handleFirstNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Last name:\\r\\n        <input\\r\\n          value={person.lastName}\\r\\n          onChange={handleLastNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Email:\\r\\n        <input\\r\\n          value={person.email}\\r\\n          onChange={handleEmailChange}\\r\\n        />\\r\\n      </label>\\r\\n      <p>\\r\\n        {person.firstName}{' '}\\r\\n        {person.lastName}{' '}\\r\\n        ({person.email})\\r\\n      </p>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\r\\ninput { margin-left: 5px; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"104\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"请注意 \",[\"$r\",\"code\",null,{\"children\":\"...\"}],\" 展开语法本质是是“浅拷贝”——它只会复制一层。这使得它的执行速度很快，但是也意味着当你想要更新一个嵌套属性时，你必须得多次使用展开语法。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"using-a-single-event-handler-for-multiple-fields\",\"children\":\"使用一个事件处理函数来更新多个字段 \"}],[\"$r\",\"p\",null,{\"children\":[\"你也可以在对象的定义中使用 \",[\"$r\",\"code\",null,{\"children\":\"[\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"]\"}],\" 括号来实现属性的动态命名。下面是同一个例子，但它使用了一个事件处理函数而不是三个：\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Form() {\\r\\n  const [person, setPerson] = useState({\\r\\n    firstName: 'Barbara',\\r\\n    lastName: 'Hepworth',\\r\\n    email: 'bhepworth@sculpture.com'\\r\\n  });\\r\\n\\r\\n  function handleChange(e) {\\r\\n    setPerson({\\r\\n      ...person,\\r\\n      [e.target.name]: e.target.value\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <label>\\r\\n        First name:\\r\\n        <input\\r\\n          name=\\\"firstName\\\"\\r\\n          value={person.firstName}\\r\\n          onChange={handleChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Last name:\\r\\n        <input\\r\\n          name=\\\"lastName\\\"\\r\\n          value={person.lastName}\\r\\n          onChange={handleChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Email:\\r\\n        <input\\r\\n          name=\\\"email\\\"\\r\\n          value={person.email}\\r\\n          onChange={handleChange}\\r\\n        />\\r\\n      </label>\\r\\n      <p>\\r\\n        {person.firstName}{' '}\\r\\n        {person.lastName}{' '}\\r\\n        ({person.email})\\r\\n      </p>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\r\\ninput { margin-left: 5px; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"在这里，\",[\"$r\",\"code\",null,{\"children\":\"e.target.name\"}],\" 引用了 \",[\"$r\",\"code\",null,{\"children\":\"<input>\"}],\" 这个 DOM 元素的 \",[\"$r\",\"code\",null,{\"children\":\"name\"}],\" 属性。\"]}]]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"updating-a-nested-object\",\"children\":\"更新一个嵌套对象 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"考虑下面这种结构的嵌套对象：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const [person, setPerson] = useState({\\r\\n  name: 'Niki de Saint Phalle',\\r\\n  artwork: {\\r\\n    title: 'Blue Nana',\\r\\n    city: 'Hamburg',\\r\\n    image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\r\\n  }\\r\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你想要更新 \",[\"$r\",\"code\",null,{\"children\":\"person.artwork.city\"}],\" 的值，用 mutation 来实现的方法非常容易理解：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"person.artwork.city = 'New Delhi';\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"但是在 React 中，你需要将 state 视为不可变的！为了修改 \",[\"$r\",\"code\",null,{\"children\":\"city\"}],\" 的值，你首先需要创建一个新的 \",[\"$r\",\"code\",null,{\"children\":\"artwork\"}],\" 对象（其中预先填充了上一个 \",[\"$r\",\"code\",null,{\"children\":\"artwork\"}],\" 对象中的数据），然后创建一个新的 \",[\"$r\",\"code\",null,{\"children\":\"person\"}],\" 对象，并使得其中的 \",[\"$r\",\"code\",null,{\"children\":\"artwork\"}],\" 属性指向新创建的 \",[\"$r\",\"code\",null,{\"children\":\"artwork\"}],\" 对象：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"const nextArtwork = { ...person.artwork, city: 'New Delhi' };\\r\\nconst nextPerson = { ...person, artwork: nextArtwork };\\r\\nsetPerson(nextPerson);\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"或者，写成一个函数调用：\"}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"setPerson({\\r\\n  ...person, // 复制其它字段的数据 \\r\\n  artwork: { // 替换 artwork 字段 \\r\\n    ...person.artwork, // 复制之前 person.artwork 中的数据\\r\\n    city: 'New Delhi' // 但是将 city 的值替换为 New Delhi！\\r\\n  }\\r\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这虽然看起来有点冗长，但对于很多情况都能有效地解决问题：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Form() {\\r\\n  const [person, setPerson] = useState({\\r\\n    name: 'Niki de Saint Phalle',\\r\\n    artwork: {\\r\\n      title: 'Blue Nana',\\r\\n      city: 'Hamburg',\\r\\n      image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\r\\n    }\\r\\n  });\\r\\n\\r\\n  function handleNameChange(e) {\\r\\n    setPerson({\\r\\n      ...person,\\r\\n      name: e.target.value\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleTitleChange(e) {\\r\\n    setPerson({\\r\\n      ...person,\\r\\n      artwork: {\\r\\n        ...person.artwork,\\r\\n        title: e.target.value\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleCityChange(e) {\\r\\n    setPerson({\\r\\n      ...person,\\r\\n      artwork: {\\r\\n        ...person.artwork,\\r\\n        city: e.target.value\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleImageChange(e) {\\r\\n    setPerson({\\r\\n      ...person,\\r\\n      artwork: {\\r\\n        ...person.artwork,\\r\\n        image: e.target.value\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <label>\\r\\n        Name:\\r\\n        <input\\r\\n          value={person.name}\\r\\n          onChange={handleNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Title:\\r\\n        <input\\r\\n          value={person.artwork.title}\\r\\n          onChange={handleTitleChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        City:\\r\\n        <input\\r\\n          value={person.artwork.city}\\r\\n          onChange={handleCityChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Image:\\r\\n        <input\\r\\n          value={person.artwork.image}\\r\\n          onChange={handleImageChange}\\r\\n        />\\r\\n      </label>\\r\\n      <p>\\r\\n        <i>{person.artwork.title}</i>\\r\\n        {' by '}\\r\\n        {person.name}\\r\\n        <br />\\r\\n        (located in {person.artwork.city})\\r\\n      </p>\\r\\n      <img \\r\\n        src={person.artwork.image} \\r\\n        alt={person.artwork.title}\\r\\n      />\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\r\\ninput { margin-left: 5px; margin-bottom: 5px; }\\r\\nimg { width: 200px; height: 200px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"124\",{\"children\":[\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"objects-are-not-really-nested\",\"children\":\"对象并非是真正嵌套的 \"}],[\"$r\",\"p\",null,{\"children\":\"下面这个对象从代码上来看是“嵌套”的：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let obj = {\\r\\n  name: 'Niki de Saint Phalle',\\r\\n  artwork: {\\r\\n    title: 'Blue Nana',\\r\\n    city: 'Hamburg',\\r\\n    image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\r\\n  }\\r\\n};\\n\"}]}],[\"$r\",\"p\",null,{\"children\":\"然而，当我们思考对象的特性时，“嵌套”并不是一个非常准确的方式。当这段代码运行的时候，不存在“嵌套”的对象。你实际上看到的是两个不同的对象：\"}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let obj1 = {\\r\\n  title: 'Blue Nana',\\r\\n  city: 'Hamburg',\\r\\n  image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\r\\n};\\r\\n\\r\\nlet obj2 = {\\r\\n  name: 'Niki de Saint Phalle',\\r\\n  artwork: obj1\\r\\n};\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"对象 \",[\"$r\",\"code\",null,{\"children\":\"obj1\"}],\" 并不处于 \",[\"$r\",\"code\",null,{\"children\":\"obj2\"}],\" 的“内部”。例如，下面的代码中，\",[\"$r\",\"code\",null,{\"children\":\"obj3\"}],\" 中的属性也可以指向 \",[\"$r\",\"code\",null,{\"children\":\"obj1\"}],\"：\"]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"let obj1 = {\\r\\n  title: 'Blue Nana',\\r\\n  city: 'Hamburg',\\r\\n  image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\r\\n};\\r\\n\\r\\nlet obj2 = {\\r\\n  name: 'Niki de Saint Phalle',\\r\\n  artwork: obj1\\r\\n};\\r\\n\\r\\nlet obj3 = {\\r\\n  name: 'Copycat',\\r\\n  artwork: obj1\\r\\n};\\n\"}]}],[\"$r\",\"p\",null,{\"children\":[\"如果你直接修改 \",[\"$r\",\"code\",null,{\"children\":\"obj3.artwork.city\"}],\"，就会同时影响 \",[\"$r\",\"code\",null,{\"children\":\"obj2.artwork.city\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"obj1.city\"}],\"。这是因为 \",[\"$r\",\"code\",null,{\"children\":\"obj3.artwork\"}],\"、\",[\"$r\",\"code\",null,{\"children\":\"obj2.artwork\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"obj1\"}],\" 都指向同一个对象。当你用“嵌套”的方式看待对象时，很难看出这一点。相反，它们是相互独立的对象，只不过是用属性“指向”彼此而已。\"]}]]}],\"\\n\",[\"$r\",\"h3\",null,{\"id\":\"write-concise-update-logic-with-immer\",\"children\":\"使用 Immer 编写简洁的更新逻辑 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"如果你的 state 有多层的嵌套，你或许应该考虑 \",[\"$r\",\"a\",null,{\"href\":\"/learn/choosing-the-state-structure#avoid-deeply-nested-state\",\"children\":\"将其扁平化\"}],\"。但是，如果你不想改变 state 的数据结构，你可能更喜欢用一种更便捷的方式来实现嵌套展开的效果。\",[\"$r\",\"a\",null,{\"href\":\"https://github.com/immerjs/use-immer\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Immer\"}],\" 是一个非常流行的库，它可以让你使用简便但可以直接修改的语法编写代码，并会帮你处理好复制的过程。通过使用 Immer，你写出的代码看起来就像是你“打破了规则”而直接修改了对象：\"]}],\"\\n\",[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"updatePerson(draft => {\\r\\n  draft.artwork.city = 'Lagos';\\r\\n});\\n\"}]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"但是不同于一般的 mutation，它并不会覆盖之前的 state！\"}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"how-does-immer-work\",\"children\":\"Immer 是如何运行的？ \"}],[\"$r\",\"p\",null,{\"children\":[\"由 Immer 提供的 \",[\"$r\",\"code\",null,{\"children\":\"draft\"}],\" 是一种特殊类型的对象，被称为 \",[\"$r\",\"a\",null,{\"href\":\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy\",\"target\":\"_blank\",\"rel\":\"nofollow noopener noreferrer\",\"children\":\"Proxy\"}],\"，它会记录你用它所进行的操作。这就是你能够随心所欲地直接修改对象的原因所在！从原理上说，Immer 会弄清楚 \",[\"$r\",\"code\",null,{\"children\":\"draft\"}],\" 对象的哪些部分被改变了，并会依照你的修改创建出一个全新的对象。\"]}]]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"尝试使用 Immer:\"}],\"\\n\",[\"$r\",\"ol\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"运行 \",[\"$r\",\"code\",null,{\"children\":\"npm install use-immer\"}],\" 添加 Immer 依赖\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"用 \",[\"$r\",\"code\",null,{\"children\":\"import { useImmer } from 'use-immer'\"}],\" 替换掉 \",[\"$r\",\"code\",null,{\"children\":\"import { useState } from 'react'\"}]]}],\"\\n\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"下面我们把上面的例子用 Immer 实现一下：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useImmer } from 'use-immer';\\r\\n\\r\\nexport default function Form() {\\r\\n  const [person, updatePerson] = useImmer({\\r\\n    name: 'Niki de Saint Phalle',\\r\\n    artwork: {\\r\\n      title: 'Blue Nana',\\r\\n      city: 'Hamburg',\\r\\n      image: 'https://i.imgur.com/Sd1AgUOm.jpg',\\r\\n    }\\r\\n  });\\r\\n\\r\\n  function handleNameChange(e) {\\r\\n    updatePerson(draft => {\\r\\n      draft.name = e.target.value;\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleTitleChange(e) {\\r\\n    updatePerson(draft => {\\r\\n      draft.artwork.title = e.target.value;\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleCityChange(e) {\\r\\n    updatePerson(draft => {\\r\\n      draft.artwork.city = e.target.value;\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleImageChange(e) {\\r\\n    updatePerson(draft => {\\r\\n      draft.artwork.image = e.target.value;\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <label>\\r\\n        Name:\\r\\n        <input\\r\\n          value={person.name}\\r\\n          onChange={handleNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Title:\\r\\n        <input\\r\\n          value={person.artwork.title}\\r\\n          onChange={handleTitleChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        City:\\r\\n        <input\\r\\n          value={person.artwork.city}\\r\\n          onChange={handleCityChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Image:\\r\\n        <input\\r\\n          value={person.artwork.image}\\r\\n          onChange={handleImageChange}\\r\\n        />\\r\\n      </label>\\r\\n      <p>\\r\\n        <i>{person.artwork.title}</i>\\r\\n        {' by '}\\r\\n        {person.name}\\r\\n        <br />\\r\\n        (located in {person.artwork.city})\\r\\n      </p>\\r\\n      <img \\r\\n        src={person.artwork.image} \\r\\n        alt={person.artwork.title}\\r\\n      />\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json\",\"children\":\"{\\r\\n  \\\"dependencies\\\": {\\r\\n    \\\"immer\\\": \\\"1.7.3\\\",\\r\\n    \\\"react\\\": \\\"latest\\\",\\r\\n    \\\"react-dom\\\": \\\"latest\\\",\\r\\n    \\\"react-scripts\\\": \\\"latest\\\",\\r\\n    \\\"use-immer\\\": \\\"0.5.1\\\"\\r\\n  },\\r\\n  \\\"scripts\\\": {\\r\\n    \\\"start\\\": \\\"react-scripts start\\\",\\r\\n    \\\"build\\\": \\\"react-scripts build\\\",\\r\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\r\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\r\\n  }\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\r\\ninput { margin-left: 5px; margin-bottom: 5px; }\\r\\nimg { width: 200px; height: 200px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"132\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"可以看到，事件处理函数变得更简洁了。你可以随意在一个组件中同时使用 \",[\"$r\",\"code\",null,{\"children\":\"useState\"}],\" 和 \",[\"$r\",\"code\",null,{\"children\":\"useImmer\"}],\"。如果你想要写出更简洁的更新处理函数，Immer 会是一个不错的选择，尤其是当你的 state 中有嵌套，并且复制对象会带来重复的代码时。\"]}],\"\\n\",[\"$r\",\"DeepDive\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"why-is-mutating-state-not-recommended-in-react\",\"children\":\"为什么在 React 中不推荐直接修改 state？ \"}],[\"$r\",\"p\",null,{\"children\":\"有以下几个原因：\"}],[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"调试\"}],\"：如果你使用 \",[\"$r\",\"code\",null,{\"children\":\"console.log\"}],\" 并且不直接修改 state，你之前日志中的 state 的值就不会被新的 state 变化所影响。这样你就可以清楚地看到两次渲染之间 state 的值发生了什么变化\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"优化\"}],\"：React 常见的 \",[\"$r\",\"a\",null,{\"href\":\"/reference/react/memo\",\"children\":\"优化策略\"}],\" 依赖于如果之前的 props 或者 state 的值和下一次相同就跳过渲染。如果你从未直接修改 state ，那么你就可以很快看到 state 是否发生了变化。如果 \",[\"$r\",\"code\",null,{\"children\":\"prevObj === obj\"}],\"，那么你就可以肯定这个对象内部并没有发生改变。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"新功能\"}],\"：我们正在构建的 React 的新功能依赖于 state 被 \",[\"$r\",\"a\",null,{\"href\":\"/learn/state-as-a-snapshot\",\"children\":\"像快照一样看待\"}],\" 的理念。如果你直接修改 state 的历史版本，可能会影响你使用这些新功能。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"需求变更\"}],\"：有些应用功能在不出现任何修改的情况下会更容易实现，比如实现撤销/恢复、展示修改历史，或是允许用户把表单重置成某个之前的值。这是因为你可以把 state 之前的拷贝保存到内存中，并适时对其进行再次使用。如果一开始就用了直接修改 state 的方式，那么后面要实现这样的功能就会变得非常困难。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[[\"$r\",\"strong\",null,{\"children\":\"更简单的实现\"}],\"：React 并不依赖于 mutation ，所以你不需要对对象进行任何特殊操作。它不需要像很多“响应式”的解决方案一样去劫持对象的属性、总是用代理把对象包裹起来，或者在初始化时做其他工作。这也是为什么 React 允许你把任何对象存放在 state 中——不管对象有多大——而不会造成有任何额外的性能或正确性问题的原因。\"]}],\"\\n\"]}],[\"$r\",\"p\",null,{\"children\":\"在实践中，你经常可以“侥幸”直接修改 state 而不出现什么问题，但是我们强烈建议你不要这样做，这样你就可以使用我们秉承着这种理念开发的 React 新功能。未来的贡献者甚至是你未来的自己都会感谢你的！\"}]]}],\"\\n\",[\"$r\",\"Recap\",null,{\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":\"将 React 中所有的 state 都视为不可直接修改的。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"当你在 state 中存放对象时，直接修改对象并不会触发重渲染，并会改变前一次渲染“快照”中 state 的值。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"不要直接修改一个对象，而要为它创建一个 \",[\"$r\",\"strong\",null,{\"children\":\"新\"}],\" 版本，并通过把 state 设置成这个新版本来触发重新渲染。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"你可以使用这样的 \",[\"$r\",\"code\",null,{\"children\":\"{...obj, something: 'newValue'}\"}],\" 对象展开语法来创建对象的拷贝。\"]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"对象的展开语法是浅层的：它的复制深度只有一层。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"想要更新嵌套对象，你需要从你更新的位置开始自底向上为每一层都创建新的拷贝。\"}],\"\\n\",[\"$r\",\"li\",null,{\"children\":\"想要减少重复的拷贝代码，可以使用 Immer。\"}],\"\\n\"]}]}],\"\\n\"]}],[\"$r\",\"Challenges\",null,{\"children\":[[\"$r\",\"h4\",null,{\"id\":\"fix-incorrect-state-updates\",\"children\":\"修复错误的 state 更新代码 \"}],[\"$r\",\"p\",null,{\"children\":\"这个表单有几个 bug。试着点击几次增加分数的按钮。你会注意到分数并没有增加。然后试着编辑一下名字字段，你会注意到分数突然“响应”了你之前的修改。最后，试着编辑一下姓氏字段，你会发现分数完全消失了。\"}],[\"$r\",\"p\",null,{\"children\":\"你的任务就是修复所有的这些 bug。在你修复它们的同时，解释一下它们为什么会产生。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Scoreboard() {\\r\\n  const [player, setPlayer] = useState({\\r\\n    firstName: 'Ranjani',\\r\\n    lastName: 'Shettar',\\r\\n    score: 10,\\r\\n  });\\r\\n\\r\\n  function handlePlusClick() {\\r\\n    player.score++;\\r\\n  }\\r\\n\\r\\n  function handleFirstNameChange(e) {\\r\\n    setPlayer({\\r\\n      ...player,\\r\\n      firstName: e.target.value,\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleLastNameChange(e) {\\r\\n    setPlayer({\\r\\n      lastName: e.target.value\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <label>\\r\\n        Score: <b>{player.score}</b>\\r\\n        {' '}\\r\\n        <button onClick={handlePlusClick}>\\r\\n          +1\\r\\n        </button>\\r\\n      </label>\\r\\n      <label>\\r\\n        First name:\\r\\n        <input\\r\\n          value={player.firstName}\\r\\n          onChange={handleFirstNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Last name:\\r\\n        <input\\r\\n          value={player.lastName}\\r\\n          onChange={handleLastNameChange}\\r\\n        />\\r\\n      </label>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-bottom: 10px; }\\r\\ninput { margin-left: 5px; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"下面是两个 bug 都得到修复后的代码：\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Scoreboard() {\\r\\n  const [player, setPlayer] = useState({\\r\\n    firstName: 'Ranjani',\\r\\n    lastName: 'Shettar',\\r\\n    score: 10,\\r\\n  });\\r\\n\\r\\n  function handlePlusClick() {\\r\\n    setPlayer({\\r\\n      ...player,\\r\\n      score: player.score + 1,\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleFirstNameChange(e) {\\r\\n    setPlayer({\\r\\n      ...player,\\r\\n      firstName: e.target.value,\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleLastNameChange(e) {\\r\\n    setPlayer({\\r\\n      ...player,\\r\\n      lastName: e.target.value\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <label>\\r\\n        Score: <b>{player.score}</b>\\r\\n        {' '}\\r\\n        <button onClick={handlePlusClick}>\\r\\n          +1\\r\\n        </button>\\r\\n      </label>\\r\\n      <label>\\r\\n        First name:\\r\\n        <input\\r\\n          value={player.firstName}\\r\\n          onChange={handleFirstNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        Last name:\\r\\n        <input\\r\\n          value={player.lastName}\\r\\n          onChange={handleLastNameChange}\\r\\n        />\\r\\n      </label>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; }\\r\\ninput { margin-left: 5px; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"p\",null,{\"children\":[\"代码中 \",[\"$r\",\"code\",null,{\"children\":\"handlePlusClick\"}],\" 函数的问题在于它直接修改了 \",[\"$r\",\"code\",null,{\"children\":\"player\"}],\" 对象。这就造成了 React 并不知道需要重新渲染的原因，也就没有更新屏幕上分数的值。这就是为什么，当你修改名字字段的时候，state 发生了更新，state 更新触发了重新渲染，重新渲染\",[\"$r\",\"strong\",null,{\"children\":\"同时也\"}],\"更新了屏幕上的分数。\"]}],[\"$r\",\"p\",null,{\"children\":[\"代码中 \",[\"$r\",\"code\",null,{\"children\":\"handleLastNameChange\"}],\" 的问题在于它没有把 \",[\"$r\",\"code\",null,{\"children\":\"...player\"}],\" 中已有的属性复制到新的对象中。因此，当你编辑姓氏字段时，分数就丢失了。\"]}]]}],[\"$r\",\"h4\",null,{\"id\":\"find-and-fix-the-mutation\",\"children\":\"发现并修复 mutation \"}],[\"$r\",\"p\",null,{\"children\":\"在静止的背景上有一个可以拖动的方形。你可以使用下拉框来修改方形的颜色。\"}],[\"$r\",\"p\",null,{\"children\":[\"但是这里有个 bug。当你先移动了方形，再去修改它的颜色时，背景会突然“跳”到方形所在的位置（实际上背景的位置并不应该发生变化！）。但是这并不是我们想要的，\",[\"$r\",\"code\",null,{\"children\":\"Background\"}],\" 的 \",[\"$r\",\"code\",null,{\"children\":\"position\"}],\" 属性被设置为 \",[\"$r\",\"code\",null,{\"children\":\"initialPosition\"}],\"，也就是 \",[\"$r\",\"code\",null,{\"children\":\"{ x: 0, y: 0 }\"}],\"。为什么修改颜色之后，背景会移动呢？\"]}],[\"$r\",\"p\",null,{\"children\":\"找到 bug 并修复它。\"}],[\"$r\",\"Hint\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":[\"如果有一些出乎意料的改变，就是 mutation，在 \",[\"$r\",\"code\",null,{\"children\":\"App.js\"}],\" 中找到 mutation 并修复它。\"]}]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\r\\nimport Background from './Background.js';\\r\\nimport Box from './Box.js';\\r\\n\\r\\nconst initialPosition = {\\r\\n  x: 0,\\r\\n  y: 0\\r\\n};\\r\\n\\r\\nexport default function Canvas() {\\r\\n  const [shape, setShape] = useState({\\r\\n    color: 'orange',\\r\\n    position: initialPosition\\r\\n  });\\r\\n\\r\\n  function handleMove(dx, dy) {\\r\\n    shape.position.x += dx;\\r\\n    shape.position.y += dy;\\r\\n  }\\r\\n\\r\\n  function handleColorChange(e) {\\r\\n    setShape({\\r\\n      ...shape,\\r\\n      color: e.target.value\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <select\\r\\n        value={shape.color}\\r\\n        onChange={handleColorChange}\\r\\n      >\\r\\n        <option value=\\\"orange\\\">orange</option>\\r\\n        <option value=\\\"lightpink\\\">lightpink</option>\\r\\n        <option value=\\\"aliceblue\\\">aliceblue</option>\\r\\n      </select>\\r\\n      <Background\\r\\n        position={initialPosition}\\r\\n      />\\r\\n      <Box\\r\\n        color={shape.color}\\r\\n        position={shape.position}\\r\\n        onMove={handleMove}\\r\\n      >\\r\\n        Drag me!\\r\\n      </Box>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Box.js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Box({\\r\\n  children,\\r\\n  color,\\r\\n  position,\\r\\n  onMove\\r\\n}) {\\r\\n  const [\\r\\n    lastCoordinates,\\r\\n    setLastCoordinates\\r\\n  ] = useState(null);\\r\\n\\r\\n  function handlePointerDown(e) {\\r\\n    e.target.setPointerCapture(e.pointerId);\\r\\n    setLastCoordinates({\\r\\n      x: e.clientX,\\r\\n      y: e.clientY,\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handlePointerMove(e) {\\r\\n    if (lastCoordinates) {\\r\\n      setLastCoordinates({\\r\\n        x: e.clientX,\\r\\n        y: e.clientY,\\r\\n      });\\r\\n      const dx = e.clientX - lastCoordinates.x;\\r\\n      const dy = e.clientY - lastCoordinates.y;\\r\\n      onMove(dx, dy);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function handlePointerUp(e) {\\r\\n    setLastCoordinates(null);\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <div\\r\\n      onPointerDown={handlePointerDown}\\r\\n      onPointerMove={handlePointerMove}\\r\\n      onPointerUp={handlePointerUp}\\r\\n      style={{\\r\\n        width: 100,\\r\\n        height: 100,\\r\\n        cursor: 'grab',\\r\\n        backgroundColor: color,\\r\\n        position: 'absolute',\\r\\n        border: '1px solid black',\\r\\n        display: 'flex',\\r\\n        justifyContent: 'center',\\r\\n        alignItems: 'center',\\r\\n        transform: `translate(\\r\\n          ${position.x}px,\\r\\n          ${position.y}px\\r\\n        )`,\\r\\n      }}\\r\\n    >{children}</div>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Background.js\",\"children\":\"export default function Background({\\r\\n  position\\r\\n}) {\\r\\n  return (\\r\\n    <div style={{\\r\\n      position: 'absolute',\\r\\n      transform: `translate(\\r\\n        ${position.x}px,\\r\\n        ${position.y}px\\r\\n      )`,\\r\\n      width: 250,\\r\\n      height: 250,\\r\\n      backgroundColor: 'rgba(200, 200, 0, 0.2)',\\r\\n    }} />\\r\\n  );\\r\\n};\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { height: 280px; }\\r\\nselect { margin-bottom: 10px; }\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":[\"问题出在 \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" 中的 mutation 。它直接修改了 \",[\"$r\",\"code\",null,{\"children\":\"shape.position\"}],\"，但是此时 \",[\"$r\",\"code\",null,{\"children\":\"initialPosition\"}],\" 所指向的也是同一个对象。因此方形和背景都发生了移动。（因为它是 mutation，所以直到一个不相关更新——颜色变化——触发了一次重新渲染，变化才反映到屏幕上。）\"]}],[\"$r\",\"p\",null,{\"children\":[\"修复问题的方法就是从 \",[\"$r\",\"code\",null,{\"children\":\"handleMove\"}],\" 中移除这个 mutation，然后用展开运算符来复制方形对象。请注意 \",[\"$r\",\"code\",null,{\"children\":\"+=\"}],\" 是 mutation 的一种，所以你需要对它进行重写来使用普通的 \",[\"$r\",\"code\",null,{\"children\":\"+\"}],\" 操作符。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\r\\nimport Background from './Background.js';\\r\\nimport Box from './Box.js';\\r\\n\\r\\nconst initialPosition = {\\r\\n  x: 0,\\r\\n  y: 0\\r\\n};\\r\\n\\r\\nexport default function Canvas() {\\r\\n  const [shape, setShape] = useState({\\r\\n    color: 'orange',\\r\\n    position: initialPosition\\r\\n  });\\r\\n\\r\\n  function handleMove(dx, dy) {\\r\\n    setShape({\\r\\n      ...shape,\\r\\n      position: {\\r\\n        x: shape.position.x + dx,\\r\\n        y: shape.position.y + dy,\\r\\n      }\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleColorChange(e) {\\r\\n    setShape({\\r\\n      ...shape,\\r\\n      color: e.target.value\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <select\\r\\n        value={shape.color}\\r\\n        onChange={handleColorChange}\\r\\n      >\\r\\n        <option value=\\\"orange\\\">orange</option>\\r\\n        <option value=\\\"lightpink\\\">lightpink</option>\\r\\n        <option value=\\\"aliceblue\\\">aliceblue</option>\\r\\n      </select>\\r\\n      <Background\\r\\n        position={initialPosition}\\r\\n      />\\r\\n      <Box\\r\\n        color={shape.color}\\r\\n        position={shape.position}\\r\\n        onMove={handleMove}\\r\\n      >\\r\\n        Drag me!\\r\\n      </Box>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Box.js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Box({\\r\\n  children,\\r\\n  color,\\r\\n  position,\\r\\n  onMove\\r\\n}) {\\r\\n  const [\\r\\n    lastCoordinates,\\r\\n    setLastCoordinates\\r\\n  ] = useState(null);\\r\\n\\r\\n  function handlePointerDown(e) {\\r\\n    e.target.setPointerCapture(e.pointerId);\\r\\n    setLastCoordinates({\\r\\n      x: e.clientX,\\r\\n      y: e.clientY,\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handlePointerMove(e) {\\r\\n    if (lastCoordinates) {\\r\\n      setLastCoordinates({\\r\\n        x: e.clientX,\\r\\n        y: e.clientY,\\r\\n      });\\r\\n      const dx = e.clientX - lastCoordinates.x;\\r\\n      const dy = e.clientY - lastCoordinates.y;\\r\\n      onMove(dx, dy);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function handlePointerUp(e) {\\r\\n    setLastCoordinates(null);\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <div\\r\\n      onPointerDown={handlePointerDown}\\r\\n      onPointerMove={handlePointerMove}\\r\\n      onPointerUp={handlePointerUp}\\r\\n      style={{\\r\\n        width: 100,\\r\\n        height: 100,\\r\\n        cursor: 'grab',\\r\\n        backgroundColor: color,\\r\\n        position: 'absolute',\\r\\n        border: '1px solid black',\\r\\n        display: 'flex',\\r\\n        justifyContent: 'center',\\r\\n        alignItems: 'center',\\r\\n        transform: `translate(\\r\\n          ${position.x}px,\\r\\n          ${position.y}px\\r\\n        )`,\\r\\n      }}\\r\\n    >{children}</div>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Background.js\",\"children\":\"export default function Background({\\r\\n  position\\r\\n}) {\\r\\n  return (\\r\\n    <div style={{\\r\\n      position: 'absolute',\\r\\n      transform: `translate(\\r\\n        ${position.x}px,\\r\\n        ${position.y}px\\r\\n      )`,\\r\\n      width: 250,\\r\\n      height: 250,\\r\\n      backgroundColor: 'rgba(200, 200, 0, 0.2)',\\r\\n    }} />\\r\\n  );\\r\\n};\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { height: 280px; }\\r\\nselect { margin-bottom: 10px; }\\n\"}]}]]}]]}],[\"$r\",\"h4\",null,{\"id\":\"update-an-object-with-immer\",\"children\":\"使用 Immer 更新对象 \"}],[\"$r\",\"p\",null,{\"children\":[\"这里的例子和上面那段有 bug 的代码是相同的。这一次，试着用 Immer 来修复 mutation 的问题。为了方便你的练习，\",[\"$r\",\"code\",null,{\"children\":\"useImmer\"}],\" 已经被引入了，因此你只需要修改 \",[\"$r\",\"code\",null,{\"children\":\"shape\"}],\" 这个 state 变量来使用它。\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\r\\nimport { useImmer } from 'use-immer';\\r\\nimport Background from './Background.js';\\r\\nimport Box from './Box.js';\\r\\n\\r\\nconst initialPosition = {\\r\\n  x: 0,\\r\\n  y: 0\\r\\n};\\r\\n\\r\\nexport default function Canvas() {\\r\\n  const [shape, setShape] = useState({\\r\\n    color: 'orange',\\r\\n    position: initialPosition\\r\\n  });\\r\\n\\r\\n  function handleMove(dx, dy) {\\r\\n    shape.position.x += dx;\\r\\n    shape.position.y += dy;\\r\\n  }\\r\\n\\r\\n  function handleColorChange(e) {\\r\\n    setShape({\\r\\n      ...shape,\\r\\n      color: e.target.value\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <select\\r\\n        value={shape.color}\\r\\n        onChange={handleColorChange}\\r\\n      >\\r\\n        <option value=\\\"orange\\\">orange</option>\\r\\n        <option value=\\\"lightpink\\\">lightpink</option>\\r\\n        <option value=\\\"aliceblue\\\">aliceblue</option>\\r\\n      </select>\\r\\n      <Background\\r\\n        position={initialPosition}\\r\\n      />\\r\\n      <Box\\r\\n        color={shape.color}\\r\\n        position={shape.position}\\r\\n        onMove={handleMove}\\r\\n      >\\r\\n        Drag me!\\r\\n      </Box>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Box.js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Box({\\r\\n  children,\\r\\n  color,\\r\\n  position,\\r\\n  onMove\\r\\n}) {\\r\\n  const [\\r\\n    lastCoordinates,\\r\\n    setLastCoordinates\\r\\n  ] = useState(null);\\r\\n\\r\\n  function handlePointerDown(e) {\\r\\n    e.target.setPointerCapture(e.pointerId);\\r\\n    setLastCoordinates({\\r\\n      x: e.clientX,\\r\\n      y: e.clientY,\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handlePointerMove(e) {\\r\\n    if (lastCoordinates) {\\r\\n      setLastCoordinates({\\r\\n        x: e.clientX,\\r\\n        y: e.clientY,\\r\\n      });\\r\\n      const dx = e.clientX - lastCoordinates.x;\\r\\n      const dy = e.clientY - lastCoordinates.y;\\r\\n      onMove(dx, dy);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function handlePointerUp(e) {\\r\\n    setLastCoordinates(null);\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <div\\r\\n      onPointerDown={handlePointerDown}\\r\\n      onPointerMove={handlePointerMove}\\r\\n      onPointerUp={handlePointerUp}\\r\\n      style={{\\r\\n        width: 100,\\r\\n        height: 100,\\r\\n        cursor: 'grab',\\r\\n        backgroundColor: color,\\r\\n        position: 'absolute',\\r\\n        border: '1px solid black',\\r\\n        display: 'flex',\\r\\n        justifyContent: 'center',\\r\\n        alignItems: 'center',\\r\\n        transform: `translate(\\r\\n          ${position.x}px,\\r\\n          ${position.y}px\\r\\n        )`,\\r\\n      }}\\r\\n    >{children}</div>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Background.js\",\"children\":\"export default function Background({\\r\\n  position\\r\\n}) {\\r\\n  return (\\r\\n    <div style={{\\r\\n      position: 'absolute',\\r\\n      transform: `translate(\\r\\n        ${position.x}px,\\r\\n        ${position.y}px\\r\\n      )`,\\r\\n      width: 250,\\r\\n      height: 250,\\r\\n      backgroundColor: 'rgba(200, 200, 0, 0.2)',\\r\\n    }} />\\r\\n  );\\r\\n};\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { height: 280px; }\\r\\nselect { margin-bottom: 10px; }\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json\",\"children\":\"{\\r\\n  \\\"dependencies\\\": {\\r\\n    \\\"immer\\\": \\\"1.7.3\\\",\\r\\n    \\\"react\\\": \\\"latest\\\",\\r\\n    \\\"react-dom\\\": \\\"latest\\\",\\r\\n    \\\"react-scripts\\\": \\\"latest\\\",\\r\\n    \\\"use-immer\\\": \\\"0.5.1\\\"\\r\\n  },\\r\\n  \\\"scripts\\\": {\\r\\n    \\\"start\\\": \\\"react-scripts start\\\",\\r\\n    \\\"build\\\": \\\"react-scripts build\\\",\\r\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\r\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\r\\n  }\\r\\n}\\n\"}]}]]}],[\"$r\",\"Solution\",null,{\"children\":[[\"$r\",\"p\",null,{\"children\":\"下面的代码是使用 Immer 重写的。请注意代码中的事件处理函数仍然是以直接修改对象的方式书写的，但是代码不会产生任何问题了。这是因为从原理上来说，Immer 从来没有直接修改现有的对象。\"}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useImmer } from 'use-immer';\\r\\nimport Background from './Background.js';\\r\\nimport Box from './Box.js';\\r\\n\\r\\nconst initialPosition = {\\r\\n  x: 0,\\r\\n  y: 0\\r\\n};\\r\\n\\r\\nexport default function Canvas() {\\r\\n  const [shape, updateShape] = useImmer({\\r\\n    color: 'orange',\\r\\n    position: initialPosition\\r\\n  });\\r\\n\\r\\n  function handleMove(dx, dy) {\\r\\n    updateShape(draft => {\\r\\n      draft.position.x += dx;\\r\\n      draft.position.y += dy;\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleColorChange(e) {\\r\\n    updateShape(draft => {\\r\\n      draft.color = e.target.value;\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <select\\r\\n        value={shape.color}\\r\\n        onChange={handleColorChange}\\r\\n      >\\r\\n        <option value=\\\"orange\\\">orange</option>\\r\\n        <option value=\\\"lightpink\\\">lightpink</option>\\r\\n        <option value=\\\"aliceblue\\\">aliceblue</option>\\r\\n      </select>\\r\\n      <Background\\r\\n        position={initialPosition}\\r\\n      />\\r\\n      <Box\\r\\n        color={shape.color}\\r\\n        position={shape.position}\\r\\n        onMove={handleMove}\\r\\n      >\\r\\n        Drag me!\\r\\n      </Box>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Box.js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Box({\\r\\n  children,\\r\\n  color,\\r\\n  position,\\r\\n  onMove\\r\\n}) {\\r\\n  const [\\r\\n    lastCoordinates,\\r\\n    setLastCoordinates\\r\\n  ] = useState(null);\\r\\n\\r\\n  function handlePointerDown(e) {\\r\\n    e.target.setPointerCapture(e.pointerId);\\r\\n    setLastCoordinates({\\r\\n      x: e.clientX,\\r\\n      y: e.clientY,\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handlePointerMove(e) {\\r\\n    if (lastCoordinates) {\\r\\n      setLastCoordinates({\\r\\n        x: e.clientX,\\r\\n        y: e.clientY,\\r\\n      });\\r\\n      const dx = e.clientX - lastCoordinates.x;\\r\\n      const dy = e.clientY - lastCoordinates.y;\\r\\n      onMove(dx, dy);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function handlePointerUp(e) {\\r\\n    setLastCoordinates(null);\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <div\\r\\n      onPointerDown={handlePointerDown}\\r\\n      onPointerMove={handlePointerMove}\\r\\n      onPointerUp={handlePointerUp}\\r\\n      style={{\\r\\n        width: 100,\\r\\n        height: 100,\\r\\n        cursor: 'grab',\\r\\n        backgroundColor: color,\\r\\n        position: 'absolute',\\r\\n        border: '1px solid black',\\r\\n        display: 'flex',\\r\\n        justifyContent: 'center',\\r\\n        alignItems: 'center',\\r\\n        transform: `translate(\\r\\n          ${position.x}px,\\r\\n          ${position.y}px\\r\\n        )`,\\r\\n      }}\\r\\n    >{children}</div>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Background.js\",\"children\":\"export default function Background({\\r\\n  position\\r\\n}) {\\r\\n  return (\\r\\n    <div style={{\\r\\n      position: 'absolute',\\r\\n      transform: `translate(\\r\\n        ${position.x}px,\\r\\n        ${position.y}px\\r\\n      )`,\\r\\n      width: 250,\\r\\n      height: 250,\\r\\n      backgroundColor: 'rgba(200, 200, 0, 0.2)',\\r\\n    }} />\\r\\n  );\\r\\n};\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"body { height: 280px; }\\r\\nselect { margin-bottom: 10px; }\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-json\",\"meta\":\"package.json\",\"children\":\"{\\r\\n  \\\"dependencies\\\": {\\r\\n    \\\"immer\\\": \\\"1.7.3\\\",\\r\\n    \\\"react\\\": \\\"latest\\\",\\r\\n    \\\"react-dom\\\": \\\"latest\\\",\\r\\n    \\\"react-scripts\\\": \\\"latest\\\",\\r\\n    \\\"use-immer\\\": \\\"0.5.1\\\"\\r\\n  },\\r\\n  \\\"scripts\\\": {\\r\\n    \\\"start\\\": \\\"react-scripts start\\\",\\r\\n    \\\"build\\\": \\\"react-scripts build\\\",\\r\\n    \\\"test\\\": \\\"react-scripts test --env=jsdom\\\",\\r\\n    \\\"eject\\\": \\\"react-scripts eject\\\"\\r\\n  }\\r\\n}\\n\"}]}]]}]]}]]}]]","toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#whats-a-mutation\",\"depth\":2,\"text\":\"什么是 mutation？ \"},{\"url\":\"#treat-state-as-read-only\",\"depth\":2,\"text\":\"将 state 视为只读的 \"},{\"url\":\"#copying-objects-with-the-spread-syntax\",\"depth\":2,\"text\":\"使用展开语法复制对象 \"},{\"url\":\"#updating-a-nested-object\",\"depth\":2,\"text\":\"更新一个嵌套对象 \"},{\"url\":\"#write-concise-update-logic-with-immer\",\"depth\":3,\"text\":\"使用 Immer 编写简洁的更新逻辑 \"},{\"url\":\"#recap\",\"depth\":2,\"text\":\"Recap\"},{\"url\":\"#challenges\",\"depth\":2,\"text\":\"Challenges\"}]","meta":{"title":"更新 state 中的对象","translators":["Neo42","yliaz","Debbl"]}},"__N_SSG":true}