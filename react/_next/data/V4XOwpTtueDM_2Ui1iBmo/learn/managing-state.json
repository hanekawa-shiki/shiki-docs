{"pageProps":{"content":"[[\"$r\",\"MaxWidth\",\"10\",{\"children\":[[\"$r\",\"Intro\",null,{\"children\":[\"$r\",\"p\",null,{\"children\":\"随着你的应用不断变大，更有意识的去关注应用状态如何组织，以及数据如何在组件之间流动会对你很有帮助。冗余或重复的状态往往是缺陷的根源。在本节中，你将学习如何组织好状态，如何保持状态更新逻辑的可维护性，以及如何跨组件共享状态。\"}]}],\"\\n\",[\"$r\",\"YouWillLearn\",null,{\"isChapter\":true,\"children\":[\"$r\",\"ul\",null,{\"children\":[\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/reacting-to-input-with-state\",\"children\":\"如何将 UI 变更视为状态变更\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/choosing-the-state-structure\",\"children\":\"如何组织好状态\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/sharing-state-between-components\",\"children\":\"如何使用“状态提升”在组件之间共享状态\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/preserving-and-resetting-state\",\"children\":\"如何控制状态的保留或重置\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"如何在函数中整合复杂的状态逻辑\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"如何避免数据通过 prop 逐级透传\"}]}],\"\\n\",[\"$r\",\"li\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/scaling-up-with-reducer-and-context\",\"children\":\"如何随着应用的增长去扩展状态管理\"}]}],\"\\n\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"reacting-to-input-with-state\",\"children\":\"使用状态响应输入 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"使用 React，你不用直接从代码层面修改 UI。例如，不用编写诸如“禁用按钮”、“启用按钮”、“显示成功消息”等命令。相反，你只需要描述组件在不同状态（“初始状态”、“输入状态”、“成功状态”）下希望展现的 UI，然后根据用户输入触发状态更改。这和设计师对 UI 的理解很相似。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"下面是一个使用 React 编写的反馈表单。请注意看它是如何使用 \",[\"$r\",\"code\",null,{\"children\":\"status\"}],\" 这个状态变量来决定启用或禁用提交按钮，以及是否显示成功消息的。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Form() {\\r\\n  const [answer, setAnswer] = useState('');\\r\\n  const [error, setError] = useState(null);\\r\\n  const [status, setStatus] = useState('typing');\\r\\n\\r\\n  if (status === 'success') {\\r\\n    return <h1>答对了！</h1>\\r\\n  }\\r\\n\\r\\n  async function handleSubmit(e) {\\r\\n    e.preventDefault();\\r\\n    setStatus('submitting');\\r\\n    try {\\r\\n      await submitForm(answer);\\r\\n      setStatus('success');\\r\\n    } catch (err) {\\r\\n      setStatus('typing');\\r\\n      setError(err);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  function handleTextareaChange(e) {\\r\\n    setAnswer(e.target.value);\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <h2>城市测验</h2>\\r\\n      <p>\\r\\n        哪个城市有把空气变成饮用水的广告牌？\\r\\n      </p>\\r\\n      <form onSubmit={handleSubmit}>\\r\\n        <textarea\\r\\n          value={answer}\\r\\n          onChange={handleTextareaChange}\\r\\n          disabled={status === 'submitting'}\\r\\n        />\\r\\n        <br />\\r\\n        <button disabled={\\r\\n          answer.length === 0 ||\\r\\n          status === 'submitting'\\r\\n        }>\\r\\n          提交\\r\\n        </button>\\r\\n        {error !== null &&\\r\\n          <p className=\\\"Error\\\">\\r\\n            {error.message}\\r\\n          </p>\\r\\n        }\\r\\n      </form>\\r\\n    </>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction submitForm(answer) {\\r\\n  // 模拟接口请求\\r\\n  return new Promise((resolve, reject) => {\\r\\n    setTimeout(() => {\\r\\n      let shouldError = answer.toLowerCase() !== 'lima'\\r\\n      if (shouldError) {\\r\\n        reject(new Error('猜的不错，但答案不对。再试试看吧！'));\\r\\n      } else {\\r\\n        resolve();\\r\\n      }\\r\\n    }, 1500);\\r\\n  });\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".Error { color: red; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"20\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/reacting-to-input-with-state\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/reacting-to-input-with-state\",\"children\":\"用状态对输入作出响应\"}]}],\" 来学习如何以状态驱动的思维处理交互。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"choosing-the-state-structure\",\"children\":\"选择状态结构 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"良好的状态组织，可以区分开易于修改和调试的组件与频繁出问题的组件。最重要的原则是，状态不应包含冗余或重复的信息。如果包含一些多余的状态，我们会很容易忘记去更新它，从而导致问题产生！\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"例如，这个表单有一个多余的 \",[\"$r\",\"code\",null,{\"children\":\"fullName\"}],\" 状态变量：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Form() {\\r\\n  const [firstName, setFirstName] = useState('');\\r\\n  const [lastName, setLastName] = useState('');\\r\\n  const [fullName, setFullName] = useState('');\\r\\n\\r\\n  function handleFirstNameChange(e) {\\r\\n    setFirstName(e.target.value);\\r\\n    setFullName(e.target.value + ' ' + lastName);\\r\\n  }\\r\\n\\r\\n  function handleLastNameChange(e) {\\r\\n    setLastName(e.target.value);\\r\\n    setFullName(firstName + ' ' + e.target.value);\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <h2>让我们帮你登记</h2>\\r\\n      <label>\\r\\n        名：{' '}\\r\\n        <input\\r\\n          value={firstName}\\r\\n          onChange={handleFirstNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        姓：{' '}\\r\\n        <input\\r\\n          value={lastName}\\r\\n          onChange={handleLastNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <p>\\r\\n        你的票据将签发给：<b>{fullName}</b>\\r\\n      </p>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"24\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"你可以移除它并在组件渲染时通过计算 \",[\"$r\",\"code\",null,{\"children\":\"fullName\"}],\" 来简化代码：\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Form() {\\r\\n  const [firstName, setFirstName] = useState('');\\r\\n  const [lastName, setLastName] = useState('');\\r\\n\\r\\n  const fullName = firstName + ' ' + lastName;\\r\\n\\r\\n  function handleFirstNameChange(e) {\\r\\n    setFirstName(e.target.value);\\r\\n  }\\r\\n\\r\\n  function handleLastNameChange(e) {\\r\\n    setLastName(e.target.value);\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <h2>让我们帮你登记</h2>\\r\\n      <label>\\r\\n        名：{' '}\\r\\n        <input\\r\\n          value={firstName}\\r\\n          onChange={handleFirstNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <label>\\r\\n        姓：{' '}\\r\\n        <input\\r\\n          value={lastName}\\r\\n          onChange={handleLastNameChange}\\r\\n        />\\r\\n      </label>\\r\\n      <p>\\r\\n        你的票将发给：<b>{fullName}</b>\\r\\n      </p>\\r\\n    </>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"label { display: block; margin-bottom: 5px; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"36\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":\"这看起来似乎只是一个小改动，但却可以避免很多潜在的问题。\"}],\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/choosing-the-state-structure\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/choosing-the-state-structure\",\"children\":\"选择状态结构\"}]}],\" 来学习如何组织状态并避开错误。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"sharing-state-between-components\",\"children\":\"在组件间共享状态 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"有时候你希望两个组件的状态始终同步更改。要实现这一点，可以将相关状态从这两个组件上移除，并把这些状态移到最近的父级组件，然后通过 props 将状态传递给这两个组件。这被称为“状态提升”，这是编写 React 代码时常做的事。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"在以下示例中，要求每次只能激活一个面板。要实现这一点，父组件将管理激活状态并为其子组件指定 prop，而不是将激活状态保留在各自的子组件中。\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Accordion() {\\r\\n  const [activeIndex, setActiveIndex] = useState(0);\\r\\n  return (\\r\\n    <>\\r\\n      <h2>Almaty, Kazakhstan</h2>\\r\\n      <Panel\\r\\n        title=\\\"关于\\\"\\r\\n        isActive={activeIndex === 0}\\r\\n        onShow={() => setActiveIndex(0)}\\r\\n      >\\r\\n        阿拉木图人口约200万，是哈萨克斯坦最大的城市。在1929年至1997年之间，它是该国首都。\\r\\n      </Panel>\\r\\n      <Panel\\r\\n        title=\\\"词源\\\"\\r\\n        isActive={activeIndex === 1}\\r\\n        onShow={() => setActiveIndex(1)}\\r\\n      >\\r\\n        这个名字源于哈萨克语 <span lang=\\\"kk-KZ\\\">алма</span>，是“苹果”的意思，通常被翻译成“满是苹果”。事实上，阿拉木图周围的地区被认为是苹果的祖籍，<i lang=\\\"la\\\">Malus sieversii</i> 被认为是目前本土苹果的祖先。\\r\\n      </Panel>\\r\\n    </>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Panel({\\r\\n  title,\\r\\n  children,\\r\\n  isActive,\\r\\n  onShow\\r\\n}) {\\r\\n  return (\\r\\n    <section className=\\\"panel\\\">\\r\\n      <h3>{title}</h3>\\r\\n      {isActive ? (\\r\\n        <p>{children}</p>\\r\\n      ) : (\\r\\n        <button onClick={onShow}>\\r\\n          显示\\r\\n        </button>\\r\\n      )}\\r\\n    </section>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"h3, p { margin: 5px 0px; }\\r\\n.panel {\\r\\n  padding: 10px;\\r\\n  border: 1px solid #aaa;\\r\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"46\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/sharing-state-between-components\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/sharing-state-between-components\",\"children\":\"在组件间共享状态\"}]}],\" 来学习如何提升状态并保持组件同步。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"preserving-and-resetting-state\",\"children\":\"保留和重置状态 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"当你重新渲染一个组件时， React 需要决定组件树中的哪些部分要保留和更新，以及丢弃或重新创建。在大多数情况下， React 的自动处理机制已经做得足够好了。默认情况下，React 会保留树中与先前渲染的组件树“匹配”的部分。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"然而，有时这并不是你想要的。例如，在下面这个程序中，输入内容后再切换收件人并不会清空输入框。这可能会导致用户不小心发错消息：\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\r\\nimport Chat from './Chat.js';\\r\\nimport ContactList from './ContactList.js';\\r\\n\\r\\nexport default function Messenger() {\\r\\n  const [to, setTo] = useState(contacts[0]);\\r\\n  return (\\r\\n    <div>\\r\\n      <ContactList\\r\\n        contacts={contacts}\\r\\n        selectedContact={to}\\r\\n        onSelect={contact => setTo(contact)}\\r\\n      />\\r\\n      <Chat contact={to} />\\r\\n    </div>\\r\\n  )\\r\\n}\\r\\n\\r\\nconst contacts = [\\r\\n  { name: 'Taylor', email: 'taylor@mail.com' },\\r\\n  { name: 'Alice', email: 'alice@mail.com' },\\r\\n  { name: 'Bob', email: 'bob@mail.com' }\\r\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ContactList.js\",\"children\":\"export default function ContactList({\\r\\n  selectedContact,\\r\\n  contacts,\\r\\n  onSelect\\r\\n}) {\\r\\n  return (\\r\\n    <section className=\\\"contact-list\\\">\\r\\n      <ul>\\r\\n        {contacts.map(contact =>\\r\\n          <li key={contact.email}>\\r\\n            <button onClick={() => {\\r\\n              onSelect(contact);\\r\\n            }}>\\r\\n              {contact.name}\\r\\n            </button>\\r\\n          </li>\\r\\n        )}\\r\\n      </ul>\\r\\n    </section>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Chat.js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Chat({ contact }) {\\r\\n  const [text, setText] = useState('');\\r\\n  return (\\r\\n    <section className=\\\"chat\\\">\\r\\n      <textarea\\r\\n        value={text}\\r\\n        placeholder={'Chat to ' + contact.name}\\r\\n        onChange={e => setText(e.target.value)}\\r\\n      />\\r\\n      <br />\\r\\n      <button>发送给 {contact.email}</button>\\r\\n    </section>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".chat, .contact-list {\\r\\n  float: left;\\r\\n  margin-bottom: 20px;\\r\\n}\\r\\nul, li {\\r\\n  list-style: none;\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n}\\r\\nli button {\\r\\n  width: 100px;\\r\\n  padding: 10px;\\r\\n  margin-right: 10px;\\r\\n}\\r\\ntextarea {\\r\\n  height: 150px;\\r\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"50\",{\"children\":[\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"React 允许你覆盖默认行为，可通过向组件传递一个唯一 \",[\"$r\",\"code\",null,{\"children\":\"key\"}],\"（如 \",[\"$r\",\"code\",null,{\"children\":\"<Chat key={email}/>\"}],\" 来 \",[\"$r\",\"em\",null,{\"children\":\"强制\"}],\" 重置其状态。这会告诉 React ，如果收件人不同，应将其作为一个 \",[\"$r\",\"strong\",null,{\"children\":\"不同的\"}],\" \",[\"$r\",\"code\",null,{\"children\":\"Chat\"}],\" 组件，需要使用新数据和 UI（比如输入框）来重新创建它。现在，在接收者之间切换时就会重置输入框——即使渲染的是同一个组件。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useState } from 'react';\\r\\nimport Chat from './Chat.js';\\r\\nimport ContactList from './ContactList.js';\\r\\n\\r\\nexport default function Messenger() {\\r\\n  const [to, setTo] = useState(contacts[0]);\\r\\n  return (\\r\\n    <div>\\r\\n      <ContactList\\r\\n        contacts={contacts}\\r\\n        selectedContact={to}\\r\\n        onSelect={contact => setTo(contact)}\\r\\n      />\\r\\n      <Chat key={to.email} contact={to} />\\r\\n    </div>\\r\\n  )\\r\\n}\\r\\n\\r\\nconst contacts = [\\r\\n  { name: 'Taylor', email: 'taylor@mail.com' },\\r\\n  { name: 'Alice', email: 'alice@mail.com' },\\r\\n  { name: 'Bob', email: 'bob@mail.com' }\\r\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/ContactList.js\",\"children\":\"export default function ContactList({\\r\\n  selectedContact,\\r\\n  contacts,\\r\\n  onSelect\\r\\n}) {\\r\\n  return (\\r\\n    <section className=\\\"contact-list\\\">\\r\\n      <ul>\\r\\n        {contacts.map(contact =>\\r\\n          <li key={contact.email}>\\r\\n            <button onClick={() => {\\r\\n              onSelect(contact);\\r\\n            }}>\\r\\n              {contact.name}\\r\\n            </button>\\r\\n          </li>\\r\\n        )}\\r\\n      </ul>\\r\\n    </section>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Chat.js\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function Chat({ contact }) {\\r\\n  const [text, setText] = useState('');\\r\\n  return (\\r\\n    <section className=\\\"chat\\\">\\r\\n      <textarea\\r\\n        value={text}\\r\\n        placeholder={'Chat to ' + contact.name}\\r\\n        onChange={e => setText(e.target.value)}\\r\\n      />\\r\\n      <br />\\r\\n      <button>发送给 {contact.email}</button>\\r\\n    </section>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".chat, .contact-list {\\r\\n  float: left;\\r\\n  margin-bottom: 20px;\\r\\n}\\r\\nul, li {\\r\\n  list-style: none;\\r\\n  margin: 0;\\r\\n  padding: 0;\\r\\n}\\r\\nli button {\\r\\n  width: 100px;\\r\\n  padding: 10px;\\r\\n  margin-right: 10px;\\r\\n}\\r\\ntextarea {\\r\\n  height: 150px;\\r\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"58\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/preserving-and-resetting-state\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/preserving-and-resetting-state\",\"children\":\"保留和重置状态\"}]}],\" 来学习状态的生命周期以及如何控制它。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"extracting-state-logic-into-a-reducer\",\"children\":\"提取状态逻辑到 reducer 中 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"对于那些需要更新多个状态的组件来说，过于分散的事件处理程序可能会令人不知所措。对于这种情况，你可以在组件外部将所有状态更新逻辑合并到一个称为 “reducer” 的函数中。这样，事件处理程序就会变得简洁，因为它们只需要指定用户的 “actions”。在文件的底部，reducer 函数指定状态应该如何更新以响应每个 action！\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import { useReducer } from 'react';\\r\\nimport AddTask from './AddTask.js';\\r\\nimport TaskList from './TaskList.js';\\r\\n\\r\\nexport default function TaskApp() {\\r\\n  const [tasks, dispatch] = useReducer(\\r\\n    tasksReducer,\\r\\n    initialTasks\\r\\n  );\\r\\n\\r\\n  function handleAddTask(text) {\\r\\n    dispatch({\\r\\n      type: 'added',\\r\\n      id: nextId++,\\r\\n      text: text,\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleChangeTask(task) {\\r\\n    dispatch({\\r\\n      type: 'changed',\\r\\n      task: task\\r\\n    });\\r\\n  }\\r\\n\\r\\n  function handleDeleteTask(taskId) {\\r\\n    dispatch({\\r\\n      type: 'deleted',\\r\\n      id: taskId\\r\\n    });\\r\\n  }\\r\\n\\r\\n  return (\\r\\n    <>\\r\\n      <h1>布拉格行程</h1>\\r\\n      <AddTask\\r\\n        onAddTask={handleAddTask}\\r\\n      />\\r\\n      <TaskList\\r\\n        tasks={tasks}\\r\\n        onChangeTask={handleChangeTask}\\r\\n        onDeleteTask={handleDeleteTask}\\r\\n      />\\r\\n    </>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction tasksReducer(tasks, action) {\\r\\n  switch (action.type) {\\r\\n    case 'added': {\\r\\n      return [...tasks, {\\r\\n        id: action.id,\\r\\n        text: action.text,\\r\\n        done: false\\r\\n      }];\\r\\n    }\\r\\n    case 'changed': {\\r\\n      return tasks.map(t => {\\r\\n        if (t.id === action.task.id) {\\r\\n          return action.task;\\r\\n        } else {\\r\\n          return t;\\r\\n        }\\r\\n      });\\r\\n    }\\r\\n    case 'deleted': {\\r\\n      return tasks.filter(t => t.id !== action.id);\\r\\n    }\\r\\n    default: {\\r\\n      throw Error('未知操作：' + action.type);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nlet nextId = 3;\\r\\nconst initialTasks = [\\r\\n  { id: 0, text: '参观卡夫卡博物馆', done: true },\\r\\n  { id: 1, text: '看木偶戏', done: false },\\r\\n  { id: 2, text: '列侬墙图片', done: false }\\r\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTask.js hidden\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function AddTask({ onAddTask }) {\\r\\n  const [text, setText] = useState('');\\r\\n  return (\\r\\n    <>\\r\\n      <input\\r\\n        placeholder=\\\"添加任务\\\"\\r\\n        value={text}\\r\\n        onChange={e => setText(e.target.value)}\\r\\n      />\\r\\n      <button onClick={() => {\\r\\n        setText('');\\r\\n        onAddTask(text);\\r\\n      }}>添加</button>\\r\\n    </>\\r\\n  )\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js hidden\",\"children\":\"import { useState } from 'react';\\r\\n\\r\\nexport default function TaskList({\\r\\n  tasks,\\r\\n  onChangeTask,\\r\\n  onDeleteTask\\r\\n  }) {\\r\\n  return (\\r\\n    <ul>\\r\\n      {tasks.map(task => (\\r\\n        <li key={task.id}>\\r\\n          <Task\\r\\n            task={task}\\r\\n            onChange={onChangeTask}\\r\\n            onDelete={onDeleteTask}\\r\\n          />\\r\\n        </li>\\r\\n      ))}\\r\\n    </ul>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Task({ task, onChange, onDelete }) {\\r\\n  const [isEditing, setIsEditing] = useState(false);\\r\\n  let taskContent;\\r\\n  if (isEditing) {\\r\\n    taskContent = (\\r\\n      <>\\r\\n        <input\\r\\n          value={task.text}\\r\\n          onChange={e => {\\r\\n            onChange({\\r\\n              ...task,\\r\\n              text: e.target.value\\r\\n            });\\r\\n          }} />\\r\\n        <button onClick={() => setIsEditing(false)}>\\r\\n          保存\\r\\n        </button>\\r\\n      </>\\r\\n    );\\r\\n  } else {\\r\\n    taskContent = (\\r\\n      <>\\r\\n        {task.text}\\r\\n        <button onClick={() => setIsEditing(true)}>\\r\\n          编辑\\r\\n        </button>\\r\\n      </>\\r\\n    );\\r\\n  }\\r\\n  return (\\r\\n    <label>\\r\\n      <input\\r\\n        type=\\\"checkbox\\\"\\r\\n        checked={task.done}\\r\\n        onChange={e => {\\r\\n          onChange({\\r\\n            ...task,\\r\\n            done: e.target.checked\\r\\n          });\\r\\n        }}\\r\\n      />\\r\\n      {taskContent}\\r\\n      <button onClick={() => onDelete(task.id)}>\\r\\n        删除\\r\\n      </button>\\r\\n    </label>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\r\\nli { list-style-type: none; }\\r\\nul, li { margin: 0; padding: 0; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"68\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/extracting-state-logic-into-a-reducer\",\"children\":\"提取状态逻辑到 reducer 中\"}]}],\" 来学习如何在 reducer 函数中整合逻辑。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"passing-data-deeply-with-context\",\"children\":\"使用 Context 进行深层数据传递 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"通常，你会通过 props 将信息从父组件传递给子组件。但是，如果要在组件树中深入传递一些 prop，或者树里的许多组件需要使用相同的 prop，那么传递 prop 可能会变得很麻烦。Context 允许父组件将一些信息提供给它下层的任何组件，不管该组件多深层也无需通过 props 逐层透传。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"这里的 \",[\"$r\",\"code\",null,{\"children\":\"Heading\"}],\" 组件通过“询问”最近的 \",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 来确定其标题级别。每个 \",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 的级别是通过给父 \",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 添加的级别来确定的。每个 \",[\"$r\",\"code\",null,{\"children\":\"Section\"}],\" 都向它下层的所有组件提供信息，不需要逐层传递 props，而是通过 Context 来实现。\"]}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"children\":\"import Heading from './Heading.js';\\r\\nimport Section from './Section.js';\\r\\n\\r\\nexport default function Page() {\\r\\n  return (\\r\\n    <Section>\\r\\n      <Heading>大标题</Heading>\\r\\n      <Section>\\r\\n        <Heading>一级标题</Heading>\\r\\n        <Heading>一级标题</Heading>\\r\\n        <Heading>一级标题</Heading>\\r\\n        <Section>\\r\\n          <Heading>二级标题</Heading>\\r\\n          <Heading>二级标题</Heading>\\r\\n          <Heading>二级标题</Heading>\\r\\n          <Section>\\r\\n            <Heading>三级标题</Heading>\\r\\n            <Heading>三级标题</Heading>\\r\\n            <Heading>三级标题</Heading>\\r\\n          </Section>\\r\\n        </Section>\\r\\n      </Section>\\r\\n    </Section>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Section.js\",\"children\":\"import { useContext } from 'react';\\r\\nimport { LevelContext } from './LevelContext.js';\\r\\n\\r\\nexport default function Section({ children }) {\\r\\n  const level = useContext(LevelContext);\\r\\n  return (\\r\\n    <section className=\\\"section\\\">\\r\\n      <LevelContext.Provider value={level + 1}>\\r\\n        {children}\\r\\n      </LevelContext.Provider>\\r\\n    </section>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/Heading.js\",\"children\":\"import { useContext } from 'react';\\r\\nimport { LevelContext } from './LevelContext.js';\\r\\n\\r\\nexport default function Heading({ children }) {\\r\\n  const level = useContext(LevelContext);\\r\\n  switch (level) {\\r\\n    case 0:\\r\\n      throw Error('标题必须在 Section 内！');\\r\\n    case 1:\\r\\n      return <h1>{children}</h1>;\\r\\n    case 2:\\r\\n      return <h2>{children}</h2>;\\r\\n    case 3:\\r\\n      return <h3>{children}</h3>;\\r\\n    case 4:\\r\\n      return <h4>{children}</h4>;\\r\\n    case 5:\\r\\n      return <h5>{children}</h5>;\\r\\n    case 6:\\r\\n      return <h6>{children}</h6>;\\r\\n    default:\\r\\n      throw Error('未知级别：' + level);\\r\\n  }\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/LevelContext.js\",\"children\":\"import { createContext } from 'react';\\r\\n\\r\\nexport const LevelContext = createContext(0);\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\".section {\\r\\n  padding: 10px;\\r\\n  margin: 5px;\\r\\n  border-radius: 5px;\\r\\n  border: 1px solid #aaa;\\r\\n}\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"78\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/passing-data-deeply-with-context\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/passing-data-deeply-with-context\",\"children\":\"使用 Context 进行深层数据传递\"}]}],\" 来学习如何使用 Context 来代替传递 props。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"scaling-up-with-reducer-and-context\",\"children\":\"使用 Reducer 和 Context 进行状态扩展 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"Reducer 帮助你合并组件的状态更新逻辑。Context 帮助你将信息深入传递给其他组件。你可以将 reducers 和 context 组合在一起使用，以管理复杂应用的状态。\"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":\"基于这种想法，使用 reducer 来管理一个具有复杂状态的父组件。组件树中任何深度的其他组件都可以通过 context 读取其状态。还可以 dispatch 一些 action 来更新状态。\"}],\"\\n\"]}],[\"$r\",\"Sandpack\",null,{\"children\":[[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/App.js\",\"children\":\"import AddTask from './AddTask.js';\\r\\nimport TaskList from './TaskList.js';\\r\\nimport { TasksProvider } from './TasksContext.js';\\r\\n\\r\\nexport default function TaskApp() {\\r\\n  return (\\r\\n    <TasksProvider>\\r\\n      <h1>在京都休息一天</h1>\\r\\n      <AddTask />\\r\\n      <TaskList />\\r\\n    </TasksProvider>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TasksContext.js\",\"children\":\"import { createContext, useContext, useReducer } from 'react';\\r\\n\\r\\nconst TasksContext = createContext(null);\\r\\nconst TasksDispatchContext = createContext(null);\\r\\n\\r\\nexport function TasksProvider({ children }) {\\r\\n  const [tasks, dispatch] = useReducer(\\r\\n    tasksReducer,\\r\\n    initialTasks\\r\\n  );\\r\\n\\r\\n  return (\\r\\n    <TasksContext.Provider value={tasks}>\\r\\n      <TasksDispatchContext.Provider\\r\\n        value={dispatch}\\r\\n      >\\r\\n        {children}\\r\\n      </TasksDispatchContext.Provider>\\r\\n    </TasksContext.Provider>\\r\\n  );\\r\\n}\\r\\n\\r\\nexport function useTasks() {\\r\\n  return useContext(TasksContext);\\r\\n}\\r\\n\\r\\nexport function useTasksDispatch() {\\r\\n  return useContext(TasksDispatchContext);\\r\\n}\\r\\n\\r\\nfunction tasksReducer(tasks, action) {\\r\\n  switch (action.type) {\\r\\n    case 'added': {\\r\\n      return [...tasks, {\\r\\n        id: action.id,\\r\\n        text: action.text,\\r\\n        done: false\\r\\n      }];\\r\\n    }\\r\\n    case 'changed': {\\r\\n      return tasks.map(t => {\\r\\n        if (t.id === action.task.id) {\\r\\n          return action.task;\\r\\n        } else {\\r\\n          return t;\\r\\n        }\\r\\n      });\\r\\n    }\\r\\n    case 'deleted': {\\r\\n      return tasks.filter(t => t.id !== action.id);\\r\\n    }\\r\\n    default: {\\r\\n      throw Error('未知操作：' + action.type);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nconst initialTasks = [\\r\\n  { id: 0, text: '哲学家之路', done: true },\\r\\n  { id: 1, text: '参观寺庙', done: false },\\r\\n  { id: 2, text: '喝抹茶', done: false }\\r\\n];\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/AddTask.js\",\"children\":\"import { useState, useContext } from 'react';\\r\\nimport { useTasksDispatch } from './TasksContext.js';\\r\\n\\r\\nexport default function AddTask({ onAddTask }) {\\r\\n  const [text, setText] = useState('');\\r\\n  const dispatch = useTasksDispatch();\\r\\n  return (\\r\\n    <>\\r\\n      <input\\r\\n        placeholder=\\\"添加任务\\\"\\r\\n        value={text}\\r\\n        onChange={e => setText(e.target.value)}\\r\\n      />\\r\\n      <button onClick={() => {\\r\\n        setText('');\\r\\n        dispatch({\\r\\n          type: 'added',\\r\\n          id: nextId++,\\r\\n          text: text,\\r\\n        });\\r\\n      }}>添加</button>\\r\\n    </>\\r\\n  );\\r\\n}\\r\\n\\r\\nlet nextId = 3;\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-js\",\"meta\":\"src/TaskList.js\",\"children\":\"import { useState, useContext } from 'react';\\r\\nimport { useTasks, useTasksDispatch } from './TasksContext.js';\\r\\n\\r\\nexport default function TaskList() {\\r\\n  const tasks = useTasks();\\r\\n  return (\\r\\n    <ul>\\r\\n      {tasks.map(task => (\\r\\n        <li key={task.id}>\\r\\n          <Task task={task} />\\r\\n        </li>\\r\\n      ))}\\r\\n    </ul>\\r\\n  );\\r\\n}\\r\\n\\r\\nfunction Task({ task }) {\\r\\n  const [isEditing, setIsEditing] = useState(false);\\r\\n  const dispatch = useTasksDispatch();\\r\\n  let taskContent;\\r\\n  if (isEditing) {\\r\\n    taskContent = (\\r\\n      <>\\r\\n        <input\\r\\n          value={task.text}\\r\\n          onChange={e => {\\r\\n            dispatch({\\r\\n              type: 'changed',\\r\\n              task: {\\r\\n                ...task,\\r\\n                text: e.target.value\\r\\n              }\\r\\n            });\\r\\n          }} />\\r\\n        <button onClick={() => setIsEditing(false)}>\\r\\n          保存\\r\\n        </button>\\r\\n      </>\\r\\n    );\\r\\n  } else {\\r\\n    taskContent = (\\r\\n      <>\\r\\n        {task.text}\\r\\n        <button onClick={() => setIsEditing(true)}>\\r\\n          编辑\\r\\n        </button>\\r\\n      </>\\r\\n    );\\r\\n  }\\r\\n  return (\\r\\n    <label>\\r\\n      <input\\r\\n        type=\\\"checkbox\\\"\\r\\n        checked={task.done}\\r\\n        onChange={e => {\\r\\n          dispatch({\\r\\n            type: 'changed',\\r\\n            task: {\\r\\n              ...task,\\r\\n              done: e.target.checked\\r\\n            }\\r\\n          });\\r\\n        }}\\r\\n      />\\r\\n      {taskContent}\\r\\n      <button onClick={() => {\\r\\n        dispatch({\\r\\n          type: 'deleted',\\r\\n          id: task.id\\r\\n        });\\r\\n      }}>\\r\\n        删除\\r\\n      </button>\\r\\n    </label>\\r\\n  );\\r\\n}\\n\"}]}],[\"$r\",\"pre\",null,{\"children\":[\"$r\",\"code\",null,{\"className\":\"language-css\",\"children\":\"button { margin: 5px; }\\r\\nli { list-style-type: none; }\\r\\nul, li { margin: 0; padding: 0; }\\n\"}]}]]}],[\"$r\",\"MaxWidth\",\"last\",{\"children\":[\"\\n\",[\"$r\",\"LearnMore\",null,{\"path\":\"/learn/scaling-up-with-reducer-and-context\",\"children\":[\"$r\",\"p\",null,{\"children\":[\"阅读 \",[\"$r\",\"strong\",null,{\"children\":[\"$r\",\"a\",null,{\"href\":\"/learn/scaling-up-with-reducer-and-context\",\"children\":\"使用 Reducer 和 Context 进行扩展\"}]}],\" 来学习如何在不断增长的应用程序中扩展状态管理。\"]}]}],\"\\n\",[\"$r\",\"h2\",null,{\"id\":\"whats-next\",\"children\":\"下节预告 \"}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"跳转到 \",[\"$r\",\"a\",null,{\"href\":\"/learn/reacting-to-input-with-state\",\"children\":\"使用状态响应输入\"}],\" 这一节并开始一页页的阅读！\"]}],\"\\n\",[\"$r\",\"p\",null,{\"children\":[\"当然，如果你已经熟悉了这些内容，可以去读一读 \",[\"$r\",\"a\",null,{\"href\":\"/learn/escape-hatches\",\"children\":\"Escape Hatches\"}],\"?\"]}]]}]]","toc":"[{\"url\":\"#\",\"text\":\"概览\",\"depth\":2},{\"url\":\"#reacting-to-input-with-state\",\"depth\":2,\"text\":\"使用状态响应输入 \"},{\"url\":\"#choosing-the-state-structure\",\"depth\":2,\"text\":\"选择状态结构 \"},{\"url\":\"#sharing-state-between-components\",\"depth\":2,\"text\":\"在组件间共享状态 \"},{\"url\":\"#preserving-and-resetting-state\",\"depth\":2,\"text\":\"保留和重置状态 \"},{\"url\":\"#extracting-state-logic-into-a-reducer\",\"depth\":2,\"text\":\"提取状态逻辑到 reducer 中 \"},{\"url\":\"#passing-data-deeply-with-context\",\"depth\":2,\"text\":\"使用 Context 进行深层数据传递 \"},{\"url\":\"#scaling-up-with-reducer-and-context\",\"depth\":2,\"text\":\"使用 Reducer 和 Context 进行状态扩展 \"},{\"url\":\"#whats-next\",\"depth\":2,\"text\":\"下节预告 \"}]","meta":{"title":"状态管理","translators":["qinhua","KnowsCount","QC-L"]}},"__N_SSG":true}