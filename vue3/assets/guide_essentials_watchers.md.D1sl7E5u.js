import{_ as s,c as a,o as n,b as e}from"./chunks/framework.B9NywAPp.js";const l=JSON.parse('{"title":"Watchers","description":"","frontmatter":{},"headers":[{"level":2,"title":"Basic Example","slug":"basic-example","link":"#basic-example","children":[{"level":3,"title":"Watch Source Types","slug":"watch-source-types","link":"#watch-source-types","children":[]}]},{"level":2,"title":"Deep Watchers","slug":"deep-watchers","link":"#deep-watchers","children":[]},{"level":2,"title":"Eager Watchers","slug":"eager-watchers","link":"#eager-watchers","children":[]},{"level":2,"title":"Once Watchers","slug":"once-watchers","link":"#once-watchers","children":[]},{"level":2,"title":"watchEffect()","slug":"watcheffect","link":"#watcheffect","children":[{"level":3,"title":"watch vs. watchEffect","slug":"watch-vs-watcheffect","link":"#watch-vs-watcheffect","children":[]}],"compositionOnly":true},{"level":2,"title":"Callback Flush Timing","slug":"callback-flush-timing","link":"#callback-flush-timing","children":[{"level":3,"title":"Post Watchers","slug":"post-watchers","link":"#post-watchers","children":[]},{"level":3,"title":"Sync Watchers","slug":"sync-watchers","link":"#sync-watchers","children":[]}]},{"level":2,"title":"this.$watch()","slug":"this-watch","link":"#this-watch","children":[],"optionsOnly":true},{"level":2,"title":"Stopping a Watcher","slug":"stopping-a-watcher","link":"#stopping-a-watcher","children":[]}],"relativePath":"guide/essentials/watchers.md","filePath":"guide/essentials/watchers.md"}'),o={name:"guide/essentials/watchers.md"},p=[e('<h1 id="watchers" tabindex="-1">Watchers <a class="header-anchor" href="#watchers" aria-label="Permalink to &quot;Watchers {#watchers}&quot;">​</a></h1><h2 id="basic-example" tabindex="-1">Basic Example <a class="header-anchor" href="#basic-example" aria-label="Permalink to &quot;Basic Example {#basic-example}&quot;">​</a></h2><p>Computed properties allow us to declaratively compute derived values. However, there are cases where we need to perform &quot;side effects&quot; in reaction to state changes - for example, mutating the DOM, or changing another piece of state based on the result of an async operation.</p><div class="options-api"><p>With the Options API, we can use the <a href="/api/options-state.html#watch"><code>watch</code> option</a> to trigger a function whenever a reactive property changes:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">  data</span><span style="color:#E1E4E8;">() {</span></span>\n<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      question: </span><span style="color:#9ECBFF;">&#39;&#39;</span><span style="color:#E1E4E8;">,</span></span>\n<span class="line"><span style="color:#E1E4E8;">      answer: </span><span style="color:#9ECBFF;">&#39;Questions usually contain a question mark. ;-)&#39;</span><span style="color:#E1E4E8;">,</span></span>\n<span class="line"><span style="color:#E1E4E8;">      loading: </span><span style="color:#79B8FF;">false</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  },</span></span>\n<span class="line"><span style="color:#E1E4E8;">  watch: {</span></span>\n<span class="line"><span style="color:#6A737D;">    // whenever question changes, this function will run</span></span>\n<span class="line"><span style="color:#B392F0;">    question</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newQuestion</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldQuestion</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#F97583;">      if</span><span style="color:#E1E4E8;"> (newQuestion.</span><span style="color:#B392F0;">includes</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;?&#39;</span><span style="color:#E1E4E8;">)) {</span></span>\n<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">getAnswer</span><span style="color:#E1E4E8;">()</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  },</span></span>\n<span class="line"><span style="color:#E1E4E8;">  methods: {</span></span>\n<span class="line"><span style="color:#F97583;">    async</span><span style="color:#B392F0;"> getAnswer</span><span style="color:#E1E4E8;">() {</span></span>\n<span class="line"><span style="color:#79B8FF;">      this</span><span style="color:#E1E4E8;">.loading </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> true</span></span>\n<span class="line"><span style="color:#79B8FF;">      this</span><span style="color:#E1E4E8;">.answer </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;"> &#39;Thinking...&#39;</span></span>\n<span class="line"><span style="color:#F97583;">      try</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">        const</span><span style="color:#79B8FF;"> res</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;https://yesno.wtf/api&#39;</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.answer </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> res.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">()).answer</span></span>\n<span class="line"><span style="color:#E1E4E8;">      } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (error) {</span></span>\n<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.answer </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;"> &#39;Error! Could not reach the API. &#39;</span><span style="color:#F97583;"> +</span><span style="color:#E1E4E8;"> error</span></span>\n<span class="line"><span style="color:#E1E4E8;">      } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#79B8FF;">        this</span><span style="color:#E1E4E8;">.loading </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> false</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><div class="language-template"><button title="Copy Code" class="copy"></button><span class="lang">template</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="color:#E1E4E8;">  Ask a yes/no question:</span></span>\n<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">input</span><span style="color:#B392F0;"> v-model</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">question</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">disabled</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">loading</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>\n<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;{{ answer }}&lt;/</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p><a href="https://play.vuejs.org/#eNp9VE1v2zAM/SucLnaw1D70lqUbsiKH7rB1W4++aDYdq5ElTx9xgiD/fbT8lXZFAQO2+Mgn8pH0mW2aJjl4ZCu2trkRjfucKTw22jgosOReOjhnCqDgjseL/hvAoPNGjSeAvx6tE1qtIIqWo5Er26Ih088BteCt51KeINfKcaGAT5FQc7NP4NPNYiaQmhdC7VZQcmlxMF+61yUcWu7yajVmkabQVqjwgGZmzSuudmiX4CphofQqD+ZWSAnGqz5y9I4VtmOuS9CyGA9T3QCihGu3RKhc+gJtHH2JFld+EG5Mdug2QYZ4MSKhgBd11OgqXdipEm5PKoer0Jk2kA66wB044/EF1GtOSPRUCbUnryRJosnFnK4zpC5YR7205M9bLhyUSIrGUeVcY1dpekKrdNK6MuWNiKYKXt8V98FElDxbknGxGLCpZMi7VkGMxmjzv0pz1tvO4QPcay8LULoj5RToKoTN40MCEXyEQDJTl0KFmXpNOqsUxudN+TNFzzqdJp8ODutGcod0Alg34QWwsXsaVtIjVXqe9h5bC9V4B4ebWhco7zI24hmDVSEs/yOxIPOQEFnTnjzt2emS83nYFrhcevM6nRJhS+Ys9aoUu6Av7WqoNWO5rhsh0fxownplbBqhjJEmuv0WbN2UDNtDMRXm+zfsz/bY2TL2SH1Ec8CMTZjjhqaxh7e/v+ORvieQqvaSvN8Bf6HV0veSdG5fvSoo7Su/kO1D3f13SKInuz06VHYsahzzfl0yRj+s+3dKn9O9TW7HPrPLP624lFU=" target="_blank" rel="noreferrer">Try it in the Playground</a></p><p>The <code>watch</code> option also supports a dot-delimited path as the key:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  watch: {</span></span>\n<span class="line"><span style="color:#6A737D;">    // Note: only simple paths. Expressions are not supported.</span></span>\n<span class="line"><span style="color:#9ECBFF;">    &#39;some.nested.key&#39;</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#6A737D;">      // ...</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><div class="composition-api"><p>With Composition API, we can use the <a href="/api/reactivity-core.html#watch"><code>watch</code> function</a> to trigger a callback whenever a piece of reactive state changes:</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#B392F0;"> setup</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { ref, watch } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> question</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;&#39;</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> answer</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Questions usually contain a question mark. ;-)&#39;</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> loading</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">false</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// watch works directly on a ref</span></span>\n<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(question, </span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">newQuestion</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldQuestion</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (newQuestion.</span><span style="color:#B392F0;">includes</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;?&#39;</span><span style="color:#E1E4E8;">)) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    loading.value </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> true</span></span>\n<span class="line"><span style="color:#E1E4E8;">    answer.value </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;"> &#39;Thinking...&#39;</span></span>\n<span class="line"><span style="color:#F97583;">    try</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">      const</span><span style="color:#79B8FF;"> res</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;https://yesno.wtf/api&#39;</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">      answer.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> res.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">()).answer</span></span>\n<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">catch</span><span style="color:#E1E4E8;"> (error) {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      answer.value </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;"> &#39;Error! Could not reach the API. &#39;</span><span style="color:#F97583;"> +</span><span style="color:#E1E4E8;"> error</span></span>\n<span class="line"><span style="color:#E1E4E8;">    } </span><span style="color:#F97583;">finally</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">      loading.value </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> false</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="color:#E1E4E8;">    Ask a yes/no question:</span></span>\n<span class="line"><span style="color:#E1E4E8;">    &lt;</span><span style="color:#85E89D;">input</span><span style="color:#B392F0;"> v-model</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">question</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> :</span><span style="color:#B392F0;">disabled</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">loading</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>\n<span class="line"><span style="color:#E1E4E8;">  &lt;/</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;{{ answer }}&lt;/</span><span style="color:#85E89D;">p</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p><a href="https://play.vuejs.org/#eNp9U8Fy0zAQ/ZVFF9tDah96C2mZ0umhHKBAj7oIe52oUSQjyXEyGf87KytyoDC9JPa+p+e3b1cndtd15b5HtmQrV1vZeXDo++6Wa7nrjPVwAovtAgbh6w2M0Fqzg4xOZFxzXRvtPPzq0XlpNNwEbp5lRUKEdgPaVP925jnoXS+UOgKxvJAaxEVjJ+y2hA9XxUVFGdFIvT7LtEI5JIzrqjrbGozdOmikxdqTKqmIQOV6gvOkvQDhjrqGXOOQvCzAqCa9FHBzCyeuAWT7F6uUulZ9gy7PPmZFETmQjJV7oXoke972GJHY+Axkzxupt4FalhRcYHh7TDIQcqA+LTriikFIDy0G59nG+84tq+qITpty8G0lOhmSiedefSaPZ0mnfHFG50VRRkbkj1BPceVorbFzF/+6fQj4O7g3vWpAm6Ao6JzfINw9PZaQwXuYNJJuK/U0z1nxdTLT0M7s8Ec/I3WxquLS0brRi8ddp4RHegNYhR0M/Du3pXFSAJU285osI7aSuus97K92pkF1w1nCOYNlI534qbCh8tkOVasoXkV1+sjplLZ0HGN5Vc1G2IJ5R8Np5XpKlK7J1CJntdl1UqH92k0bzdkyNc8ZRWGGz1MtbMQi1esN1tv/1F/cIdQ4e6LJod0jZzPmhV2jj/DDjy94oOcZpK57Rew3wO/ojOpjJIH2qdcN2f6DN7l9nC47RfTsHg4etUtNpZUeJz5ndPPv32j9Yve6vE6DZuNvu1R2Tg==" target="_blank" rel="noreferrer">Try it in the Playground</a></p><h3 id="watch-source-types" tabindex="-1">Watch Source Types <a class="header-anchor" href="#watch-source-types" aria-label="Permalink to &quot;Watch Source Types {#watch-source-types}&quot;">​</a></h3><p><code>watch</code>&#39;s first argument can be different types of reactive &quot;sources&quot;: it can be a ref (including computed refs), a reactive object, a <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get#description" target="_blank" rel="noreferrer">getter function</a>, or an array of multiple sources:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> x</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> y</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// single ref</span></span>\n<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(x, (</span><span style="color:#FFAB70;">newX</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">`x is ${</span><span style="color:#E1E4E8;">newX</span><span style="color:#9ECBFF;">}`</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// getter</span></span>\n<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">  () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> x.value </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> y.value,</span></span>\n<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#FFAB70;">sum</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">`sum of x + y is: ${</span><span style="color:#E1E4E8;">sum</span><span style="color:#9ECBFF;">}`</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// array of multiple sources</span></span>\n<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">([x, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> y.value], ([</span><span style="color:#FFAB70;">newX</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">newY</span><span style="color:#E1E4E8;">]) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">`x is ${</span><span style="color:#E1E4E8;">newX</span><span style="color:#9ECBFF;">} and y is ${</span><span style="color:#E1E4E8;">newY</span><span style="color:#9ECBFF;">}`</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>Do note that you can&#39;t watch a property of a reactive object like this:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> obj</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({ count: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// this won&#39;t work because we are passing a number to watch()</span></span>\n<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(obj.count, (</span><span style="color:#FFAB70;">count</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">`Count is: ${</span><span style="color:#E1E4E8;">count</span><span style="color:#9ECBFF;">}`</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>Instead, use a getter:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// instead, use a getter:</span></span>\n<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">  () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> obj.count,</span></span>\n<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#FFAB70;">count</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">`Count is: ${</span><span style="color:#E1E4E8;">count</span><span style="color:#9ECBFF;">}`</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">)</span></span></code></pre></div></div><h2 id="deep-watchers" tabindex="-1">Deep Watchers <a class="header-anchor" href="#deep-watchers" aria-label="Permalink to &quot;Deep Watchers {#deep-watchers}&quot;">​</a></h2><div class="options-api"><p><code>watch</code> is shallow by default: the callback will only trigger when the watched property has been assigned a new value - it won&#39;t trigger on nested property changes. If you want the callback to fire on all nested mutations, you need to use a deep watcher:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  watch: {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    someObject: {</span></span>\n<span class="line"><span style="color:#B392F0;">      handler</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldValue</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#6A737D;">        // Note: `newValue` will be equal to `oldValue` here</span></span>\n<span class="line"><span style="color:#6A737D;">        // on nested mutations as long as the object itself</span></span>\n<span class="line"><span style="color:#6A737D;">        // hasn&#39;t been replaced.</span></span>\n<span class="line"><span style="color:#E1E4E8;">      },</span></span>\n<span class="line"><span style="color:#E1E4E8;">      deep: </span><span style="color:#79B8FF;">true</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><div class="composition-api"><p>When you call <code>watch()</code> directly on a reactive object, it will implicitly create a deep watcher - the callback will be triggered on all nested mutations:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> obj</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({ count: </span><span style="color:#79B8FF;">0</span><span style="color:#E1E4E8;"> })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(obj, (</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldValue</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">  // fires on nested property mutations</span></span>\n<span class="line"><span style="color:#6A737D;">  // Note: `newValue` will be equal to `oldValue` here</span></span>\n<span class="line"><span style="color:#6A737D;">  // because they both point to the same object!</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">obj.count</span><span style="color:#F97583;">++</span></span></code></pre></div><p>This should be differentiated with a getter that returns a reactive object - in the latter case, the callback will only fire if the getter returns a different object:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">  () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> state.someObject,</span></span>\n<span class="line"><span style="color:#E1E4E8;">  () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">    // fires only when state.someObject is replaced</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">)</span></span></code></pre></div><p>You can, however, force the second case into a deep watcher by explicitly using the <code>deep</code> option:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">  () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> state.someObject,</span></span>\n<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldValue</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">    // Note: `newValue` will be equal to `oldValue` here</span></span>\n<span class="line"><span style="color:#6A737D;">    // *unless* state.someObject has been replaced</span></span>\n<span class="line"><span style="color:#E1E4E8;">  },</span></span>\n<span class="line"><span style="color:#E1E4E8;">  { deep: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> }</span></span>\n<span class="line"><span style="color:#E1E4E8;">)</span></span></code></pre></div></div><div class="warning custom-block"><p class="custom-block-title">Use with Caution</p><p>Deep watch requires traversing all nested properties in the watched object, and can be expensive when used on large data structures. Use it only when necessary and beware of the performance implications.</p></div><h2 id="eager-watchers" tabindex="-1">Eager Watchers <a class="header-anchor" href="#eager-watchers" aria-label="Permalink to &quot;Eager Watchers {#eager-watchers}&quot;">​</a></h2><p><code>watch</code> is lazy by default: the callback won&#39;t be called until the watched source has changed. But in some cases we may want the same callback logic to be run eagerly - for example, we may want to fetch some initial data, and then re-fetch the data whenever relevant state changes.</p><div class="options-api"><p>We can force a watcher&#39;s callback to be executed immediately by declaring it using an object with a <code>handler</code> function and the <code>immediate: true</code> option:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">  // ...</span></span>\n<span class="line"><span style="color:#E1E4E8;">  watch: {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    question: {</span></span>\n<span class="line"><span style="color:#B392F0;">      handler</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newQuestion</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#6A737D;">        // this will be run immediately on component creation.</span></span>\n<span class="line"><span style="color:#E1E4E8;">      },</span></span>\n<span class="line"><span style="color:#6A737D;">      // force eager callback execution</span></span>\n<span class="line"><span style="color:#E1E4E8;">      immediate: </span><span style="color:#79B8FF;">true</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#6A737D;">  // ...</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>The initial execution of the handler function will happen just before the <code>created</code> hook. Vue will have already processed the <code>data</code>, <code>computed</code>, and <code>methods</code> options, so those properties will be available on the first invocation.</p></div><div class="composition-api"><p>We can force a watcher&#39;s callback to be executed immediately by passing the <code>immediate: true</code> option:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">  source,</span></span>\n<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldValue</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">    // executed immediately, then again when `source` changes</span></span>\n<span class="line"><span style="color:#E1E4E8;">  },</span></span>\n<span class="line"><span style="color:#E1E4E8;">  { immediate: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> }</span></span>\n<span class="line"><span style="color:#E1E4E8;">)</span></span></code></pre></div></div><h2 id="once-watchers" tabindex="-1">Once Watchers <sup class="vt-badge" data-text="3.4+"></sup> <a class="header-anchor" href="#once-watchers" aria-label="Permalink to &quot;Once Watchers &lt;sup class=&quot;vt-badge&quot; data-text=&quot;3.4+&quot; /&gt; {#once-watchers}&quot;">​</a></h2><p>Watcher&#39;s callback will execute whenever the watched source changes. If you want the callback to trigger only once when the source changes, use the <code>once: true</code> option.</p><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  watch: {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    source: {</span></span>\n<span class="line"><span style="color:#B392F0;">      handler</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldValue</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#6A737D;">        // when `source` changes, triggers only once</span></span>\n<span class="line"><span style="color:#E1E4E8;">      },</span></span>\n<span class="line"><span style="color:#E1E4E8;">      once: </span><span style="color:#79B8FF;">true</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">  source,</span></span>\n<span class="line"><span style="color:#E1E4E8;">  (</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">oldValue</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">    // when `source` changes, triggers only once</span></span>\n<span class="line"><span style="color:#E1E4E8;">  },</span></span>\n<span class="line"><span style="color:#E1E4E8;">  { once: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> }</span></span>\n<span class="line"><span style="color:#E1E4E8;">)</span></span></code></pre></div></div><div class="composition-api"><h2 id="watcheffect" tabindex="-1"><code>watchEffect()</code> <a class="header-anchor" href="#watcheffect" aria-label="Permalink to &quot;`watchEffect()` \\*\\* {#watcheffect}&quot;">​</a></h2><p>It is common for the watcher callback to use exactly the same reactive state as the source. For example, consider the following code, which uses a watcher to load a remote resource whenever the <code>todoId</code> ref changes:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> todoId</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> data</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#E1E4E8;">  todoId,</span></span>\n<span class="line"><span style="color:#F97583;">  async</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">    const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#9ECBFF;">      `https://jsonplaceholder.typicode.com/todos/${</span><span style="color:#E1E4E8;">todoId</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">value</span><span style="color:#9ECBFF;">}`</span></span>\n<span class="line"><span style="color:#E1E4E8;">    )</span></span>\n<span class="line"><span style="color:#E1E4E8;">    data.value </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">()</span></span>\n<span class="line"><span style="color:#E1E4E8;">  },</span></span>\n<span class="line"><span style="color:#E1E4E8;">  { immediate: </span><span style="color:#79B8FF;">true</span><span style="color:#E1E4E8;"> }</span></span>\n<span class="line"><span style="color:#E1E4E8;">)</span></span></code></pre></div><p>In particular, notice how the watcher uses <code>todoId</code> twice, once as the source and then again inside the callback.</p><p>This can be simplified with <a href="/api/reactivity-core.html#watcheffect"><code>watchEffect()</code></a>. <code>watchEffect()</code> allows us to track the callback&#39;s reactive dependencies automatically. The watcher above can be rewritten as:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> response</span><span style="color:#F97583;"> =</span><span style="color:#F97583;"> await</span><span style="color:#B392F0;"> fetch</span><span style="color:#E1E4E8;">(</span></span>\n<span class="line"><span style="color:#9ECBFF;">    `https://jsonplaceholder.typicode.com/todos/${</span><span style="color:#E1E4E8;">todoId</span><span style="color:#9ECBFF;">.</span><span style="color:#E1E4E8;">value</span><span style="color:#9ECBFF;">}`</span></span>\n<span class="line"><span style="color:#E1E4E8;">  )</span></span>\n<span class="line"><span style="color:#E1E4E8;">  data.value </span><span style="color:#F97583;">=</span><span style="color:#F97583;"> await</span><span style="color:#E1E4E8;"> response.</span><span style="color:#B392F0;">json</span><span style="color:#E1E4E8;">()</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>Here, the callback will run immediately, there&#39;s no need to specify <code>immediate: true</code>. During its execution, it will automatically track <code>todoId.value</code> as a dependency (similar to computed properties). Whenever <code>todoId.value</code> changes, the callback will be run again. With <code>watchEffect()</code>, we no longer need to pass <code>todoId</code> explicitly as the source value.</p><p>You can check out <a href="/examples/#fetching-data">this example</a> of <code>watchEffect()</code> and reactive data-fetching in action.</p><p>For examples like these, with only one dependency, the benefit of <code>watchEffect()</code> is relatively small. But for watchers that have multiple dependencies, using <code>watchEffect()</code> removes the burden of having to maintain the list of dependencies manually. In addition, if you need to watch several properties in a nested data structure, <code>watchEffect()</code> may prove more efficient than a deep watcher, as it will only track the properties that are used in the callback, rather than recursively tracking all of them.</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>watchEffect</code> only tracks dependencies during its <strong>synchronous</strong> execution. When using it with an async callback, only properties accessed before the first <code>await</code> tick will be tracked.</p></div><h3 id="watch-vs-watcheffect" tabindex="-1"><code>watch</code> vs. <code>watchEffect</code> <a class="header-anchor" href="#watch-vs-watcheffect" aria-label="Permalink to &quot;`watch` vs. `watchEffect` {#watch-vs-watcheffect}&quot;">​</a></h3><p><code>watch</code> and <code>watchEffect</code> both allow us to reactively perform side effects. Their main difference is the way they track their reactive dependencies:</p><ul><li><p><code>watch</code> only tracks the explicitly watched source. It won&#39;t track anything accessed inside the callback. In addition, the callback only triggers when the source has actually changed. <code>watch</code> separates dependency tracking from the side effect, giving us more precise control over when the callback should fire.</p></li><li><p><code>watchEffect</code>, on the other hand, combines dependency tracking and side effect into one phase. It automatically tracks every reactive property accessed during its synchronous execution. This is more convenient and typically results in terser code, but makes its reactive dependencies less explicit.</p></li></ul></div><h2 id="callback-flush-timing" tabindex="-1">Callback Flush Timing <a class="header-anchor" href="#callback-flush-timing" aria-label="Permalink to &quot;Callback Flush Timing {#callback-flush-timing}&quot;">​</a></h2><p>When you mutate reactive state, it may trigger both Vue component updates and watcher callbacks created by you.</p><p>Similar to component updates, user-created watcher callbacks are batched to avoid duplicate invocations. For example, we probably don&#39;t want a watcher to fire a thousand times if we synchronously push a thousand items into an array being watched.</p><p>By default, a watcher&#39;s callback is called <strong>after</strong> parent component updates (if any), and <strong>before</strong> the owner component&#39;s DOM updates. This means if you attempt to access the owner component&#39;s own DOM inside a watcher callback, the DOM will be in a pre-update state.</p><h3 id="post-watchers" tabindex="-1">Post Watchers <a class="header-anchor" href="#post-watchers" aria-label="Permalink to &quot;Post Watchers {#post-watchers}&quot;">​</a></h3><p>If you want to access the owner component&#39;s DOM in a watcher callback <strong>after</strong> Vue has updated it, you need to specify the <code>flush: &#39;post&#39;</code> option:</p><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">  // ...</span></span>\n<span class="line"><span style="color:#E1E4E8;">  watch: {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    key: {</span></span>\n<span class="line"><span style="color:#B392F0;">      handler</span><span style="color:#E1E4E8;">() {},</span></span>\n<span class="line highlighted"><span style="color:#E1E4E8;">      flush: </span><span style="color:#9ECBFF;">&#39;post&#39;</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(source, callback, {</span></span>\n<span class="line highlighted"><span style="color:#E1E4E8;">  flush: </span><span style="color:#9ECBFF;">&#39;post&#39;</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(callback, {</span></span>\n<span class="line highlighted"><span style="color:#E1E4E8;">  flush: </span><span style="color:#9ECBFF;">&#39;post&#39;</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>Post-flush <code>watchEffect()</code> also has a convenience alias, <code>watchPostEffect()</code>:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { watchPostEffect } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">watchPostEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">  /* executed after Vue updates */</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></div><h3 id="sync-watchers" tabindex="-1">Sync Watchers <a class="header-anchor" href="#sync-watchers" aria-label="Permalink to &quot;Sync Watchers {#sync-watchers}&quot;">​</a></h3><p>It&#39;s also possible to create a watcher that fires synchronously, before any Vue-managed updates:</p><div class="options-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">  // ...</span></span>\n<span class="line"><span style="color:#E1E4E8;">  watch: {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    key: {</span></span>\n<span class="line"><span style="color:#B392F0;">      handler</span><span style="color:#E1E4E8;">() {},</span></span>\n<span class="line highlighted"><span style="color:#E1E4E8;">      flush: </span><span style="color:#9ECBFF;">&#39;sync&#39;</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></div><div class="composition-api"><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#B392F0;">watch</span><span style="color:#E1E4E8;">(source, callback, {</span></span>\n<span class="line highlighted"><span style="color:#E1E4E8;">  flush: </span><span style="color:#9ECBFF;">&#39;sync&#39;</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(callback, {</span></span>\n<span class="line highlighted"><span style="color:#E1E4E8;">  flush: </span><span style="color:#9ECBFF;">&#39;sync&#39;</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div><p>Sync <code>watchEffect()</code> also has a convenience alias, <code>watchSyncEffect()</code>:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { watchSyncEffect } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">watchSyncEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">  /* executed synchronously upon reactive data change */</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></div><div class="warning custom-block"><p class="custom-block-title">Use with Caution</p><p>Sync watchers do not have batching and triggers every time a reactive mutation is detected. It&#39;s ok to use them to watch simple boolean values, but avoid using them on data sources that might be synchronously mutated many times, e.g. arrays.</p></div><div class="options-api"><h2 id="this-watch" tabindex="-1"><code>this.$watch()</code> <a class="header-anchor" href="#this-watch" aria-label="Permalink to &quot;`this.$watch()` \\* {#this-watch}&quot;">​</a></h2><p>It&#39;s also possible to imperatively create watchers using the <a href="/api/component-instance.html#watch"><code>$watch()</code> instance method</a>:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> default</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">  created</span><span style="color:#E1E4E8;">() {</span></span>\n<span class="line"><span style="color:#79B8FF;">    this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">$watch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;question&#39;</span><span style="color:#E1E4E8;">, (</span><span style="color:#FFAB70;">newQuestion</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#6A737D;">      // ...</span></span>\n<span class="line"><span style="color:#E1E4E8;">    })</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>This is useful when you need to conditionally set up a watcher, or only watch something in response to user interaction. It also allows you to stop the watcher early.</p></div><h2 id="stopping-a-watcher" tabindex="-1">Stopping a Watcher <a class="header-anchor" href="#stopping-a-watcher" aria-label="Permalink to &quot;Stopping a Watcher {#stopping-a-watcher}&quot;">​</a></h2><div class="options-api"><p>Watchers declared using the <code>watch</code> option or the <code>$watch()</code> instance method are automatically stopped when the owner component is unmounted, so in most cases you don&#39;t need to worry about stopping the watcher yourself.</p><p>In the rare case where you need to stop a watcher before the owner component unmounts, the <code>$watch()</code> API returns a function for that:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> unwatch</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> this</span><span style="color:#E1E4E8;">.</span><span style="color:#B392F0;">$watch</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;foo&#39;</span><span style="color:#E1E4E8;">, callback)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// ...when the watcher is no longer needed:</span></span>\n<span class="line"><span style="color:#B392F0;">unwatch</span><span style="color:#E1E4E8;">()</span></span></code></pre></div></div><div class="composition-api"><p>Watchers declared synchronously inside <code>setup()</code> or <code>&lt;script setup&gt;</code> are bound to the owner component instance, and will be automatically stopped when the owner component is unmounted. In most cases, you don&#39;t need to worry about stopping the watcher yourself.</p><p>The key here is that the watcher must be created <strong>synchronously</strong>: if the watcher is created in an async callback, it won&#39;t be bound to the owner component and must be stopped manually to avoid memory leaks. Here&#39;s an example:</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#B392F0;"> setup</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { watchEffect } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// this one will be automatically stopped</span></span>\n<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// ...this one will not!</span></span>\n<span class="line"><span style="color:#B392F0;">setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">  watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {})</span></span>\n<span class="line"><span style="color:#E1E4E8;">}, </span><span style="color:#79B8FF;">100</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p>To manually stop a watcher, use the returned handle function. This works for both <code>watch</code> and <code>watchEffect</code>:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> unwatch</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// ...later, when no longer needed</span></span>\n<span class="line"><span style="color:#B392F0;">unwatch</span><span style="color:#E1E4E8;">()</span></span></code></pre></div><p>Note that there should be very few cases where you need to create watchers asynchronously, and synchronous creation should be preferred whenever possible. If you need to wait for some async data, you can make your watch logic conditional instead:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#6A737D;">// data to be loaded asynchronously</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> data</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> ref</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">null</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">  if</span><span style="color:#E1E4E8;"> (data.value) {</span></span>\n<span class="line"><span style="color:#6A737D;">    // do something when data is loaded</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span></code></pre></div></div>',35)];const t=s(o,[["render",function(s,e,l,o,t,c){return n(),a("div",null,p)}]]);export{l as __pageData,t as default};
