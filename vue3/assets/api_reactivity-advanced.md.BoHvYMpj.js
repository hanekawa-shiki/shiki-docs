import{_ as s,c as a,o as n,b as e}from"./chunks/framework.B9NywAPp.js";const l=JSON.parse('{"title":"Reactivity API: Advanced","description":"","frontmatter":{},"headers":[{"level":2,"title":"shallowRef()","slug":"shallowref","link":"#shallowref","children":[]},{"level":2,"title":"triggerRef()","slug":"triggerref","link":"#triggerref","children":[]},{"level":2,"title":"customRef()","slug":"customref","link":"#customref","children":[]},{"level":2,"title":"shallowReactive()","slug":"shallowreactive","link":"#shallowreactive","children":[]},{"level":2,"title":"shallowReadonly()","slug":"shallowreadonly","link":"#shallowreadonly","children":[]},{"level":2,"title":"toRaw()","slug":"toraw","link":"#toraw","children":[]},{"level":2,"title":"markRaw()","slug":"markraw","link":"#markraw","children":[]},{"level":2,"title":"effectScope()","slug":"effectscope","link":"#effectscope","children":[]},{"level":2,"title":"getCurrentScope()","slug":"getcurrentscope","link":"#getcurrentscope","children":[]},{"level":2,"title":"onScopeDispose()","slug":"onscopedispose","link":"#onscopedispose","children":[]}],"relativePath":"api/reactivity-advanced.md","filePath":"api/reactivity-advanced.md"}'),o={name:"api/reactivity-advanced.md"},p=[e('<h1 id="reactivity-api-advanced" tabindex="-1">Reactivity API: Advanced <a class="header-anchor" href="#reactivity-api-advanced" aria-label="Permalink to &quot;Reactivity API: Advanced {#reactivity-api-advanced}&quot;">​</a></h1><h2 id="shallowref" tabindex="-1">shallowRef() <a class="header-anchor" href="#shallowref" aria-label="Permalink to &quot;shallowRef() {#shallowref}&quot;">​</a></h2><p>Shallow version of <a href="./reactivity-core.html#ref"><code>ref()</code></a>.</p><ul><li><p><strong>Type</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> shallowRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> ShallowRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">interface</span><span style="color:#B392F0;"> ShallowRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; {</span></span>\n<span class="line"><span style="color:#FFAB70;">  value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>Details</strong></p><p>Unlike <code>ref()</code>, the inner value of a shallow ref is stored and exposed as-is, and will not be made deeply reactive. Only the <code>.value</code> access is reactive.</p><p><code>shallowRef()</code> is typically used for performance optimizations of large data structures, or integration with external state management systems.</p></li><li><p><strong>Example</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> shallowRef</span><span style="color:#E1E4E8;">({ count: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;"> })</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// does NOT trigger change</span></span>\n<span class="line"><span style="color:#E1E4E8;">state.value.count </span><span style="color:#F97583;">=</span><span style="color:#79B8FF;"> 2</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// does trigger change</span></span>\n<span class="line"><span style="color:#E1E4E8;">state.value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> { count: </span><span style="color:#79B8FF;">2</span><span style="color:#E1E4E8;"> }</span></span></code></pre></div></li><li><p><strong>See also</strong></p><ul><li><a href="/guide/best-practices/performance.html#reduce-reactivity-overhead-for-large-immutable-structures">Guide - Reduce Reactivity Overhead for Large Immutable Structures</a></li><li><a href="/guide/extras/reactivity-in-depth.html#integration-with-external-state-systems">Guide - Integration with External State Systems</a></li></ul></li></ul><h2 id="triggerref" tabindex="-1">triggerRef() <a class="header-anchor" href="#triggerref" aria-label="Permalink to &quot;triggerRef() {#triggerref}&quot;">​</a></h2><p>Force trigger effects that depends on a <a href="#shallowref">shallow ref</a>. This is typically used after making deep mutations to the inner value of a shallow ref.</p><ul><li><p><strong>Type</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> triggerRef</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">ref</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> ShallowRef</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> void</span></span></code></pre></div></li><li><p><strong>Example</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> shallow</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> shallowRef</span><span style="color:#E1E4E8;">({</span></span>\n<span class="line"><span style="color:#E1E4E8;">  greet: </span><span style="color:#9ECBFF;">&#39;Hello, world&#39;</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// Logs &quot;Hello, world&quot; once for the first run-through</span></span>\n<span class="line"><span style="color:#B392F0;">watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(shallow.value.greet)</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// This won&#39;t trigger the effect because the ref is shallow</span></span>\n<span class="line"><span style="color:#E1E4E8;">shallow.value.greet </span><span style="color:#F97583;">=</span><span style="color:#9ECBFF;"> &#39;Hello, universe&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// Logs &quot;Hello, universe&quot;</span></span>\n<span class="line"><span style="color:#B392F0;">triggerRef</span><span style="color:#E1E4E8;">(shallow)</span></span></code></pre></div></li></ul><h2 id="customref" tabindex="-1">customRef() <a class="header-anchor" href="#customref" aria-label="Permalink to &quot;customRef() {#customref}&quot;">​</a></h2><p>Creates a customized ref with explicit control over its dependency tracking and updates triggering.</p><ul><li><p><strong>Type</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> customRef</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">factory</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> CustomRefFactory</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Ref</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">type</span><span style="color:#B392F0;"> CustomRefFactory</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt; </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> (</span></span>\n<span class="line"><span style="color:#B392F0;">  track</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">,</span></span>\n<span class="line"><span style="color:#B392F0;">  trigger</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>\n<span class="line"><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">  get</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> T</span></span>\n<span class="line"><span style="color:#B392F0;">  set</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> (</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>Details</strong></p><p><code>customRef()</code> expects a factory function, which receives <code>track</code> and <code>trigger</code> functions as arguments and should return an object with <code>get</code> and <code>set</code> methods.</p><p>In general, <code>track()</code> should be called inside <code>get()</code>, and <code>trigger()</code> should be called inside <code>set()</code>. However, you have full control over when they should be called, or whether they should be called at all.</p></li><li><p><strong>Example</strong></p><p>Creating a debounced ref that only updates the value after a certain timeout after the latest set call:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { customRef } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;vue&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">export</span><span style="color:#F97583;"> function</span><span style="color:#B392F0;"> useDebouncedRef</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">value</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">delay</span><span style="color:#F97583;"> =</span><span style="color:#79B8FF;"> 200</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#F97583;">  let</span><span style="color:#E1E4E8;"> timeout</span></span>\n<span class="line"><span style="color:#F97583;">  return</span><span style="color:#B392F0;"> customRef</span><span style="color:#E1E4E8;">((</span><span style="color:#FFAB70;">track</span><span style="color:#E1E4E8;">, </span><span style="color:#FFAB70;">trigger</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">    return</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">      get</span><span style="color:#E1E4E8;">() {</span></span>\n<span class="line"><span style="color:#B392F0;">        track</span><span style="color:#E1E4E8;">()</span></span>\n<span class="line"><span style="color:#F97583;">        return</span><span style="color:#E1E4E8;"> value</span></span>\n<span class="line"><span style="color:#E1E4E8;">      },</span></span>\n<span class="line"><span style="color:#B392F0;">      set</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">newValue</span><span style="color:#E1E4E8;">) {</span></span>\n<span class="line"><span style="color:#B392F0;">        clearTimeout</span><span style="color:#E1E4E8;">(timeout)</span></span>\n<span class="line"><span style="color:#E1E4E8;">        timeout </span><span style="color:#F97583;">=</span><span style="color:#B392F0;"> setTimeout</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#E1E4E8;">          value </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> newValue</span></span>\n<span class="line"><span style="color:#B392F0;">          trigger</span><span style="color:#E1E4E8;">()</span></span>\n<span class="line"><span style="color:#E1E4E8;">        }, delay)</span></span>\n<span class="line"><span style="color:#E1E4E8;">      }</span></span>\n<span class="line"><span style="color:#E1E4E8;">    }</span></span>\n<span class="line"><span style="color:#E1E4E8;">  })</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div><p>Usage in component:</p><div class="language-vue"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">script</span><span style="color:#B392F0;"> setup</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="color:#F97583;">import</span><span style="color:#E1E4E8;"> { useDebouncedRef } </span><span style="color:#F97583;">from</span><span style="color:#9ECBFF;"> &#39;./debouncedRef&#39;</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> text</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> useDebouncedRef</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;hello&#39;</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">script</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">&lt;</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span>\n<span class="line"><span style="color:#E1E4E8;">  &lt;</span><span style="color:#85E89D;">input</span><span style="color:#B392F0;"> v-model</span><span style="color:#E1E4E8;">=</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;">text</span><span style="color:#9ECBFF;">&quot;</span><span style="color:#E1E4E8;"> /&gt;</span></span>\n<span class="line"><span style="color:#E1E4E8;">&lt;/</span><span style="color:#85E89D;">template</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div><p><a href="https://play.vuejs.org/#eNplUkFugzAQ/MqKC1SiIekxIpEq9QVV1BMXCguhBdsyaxqE/PcuGAhNfYGd3Z0ZDwzeq1K7zqB39OI205UiaJGMOieiapTUBAOYFt/wUxqRYf6OBVgotGzA30X5Bt59tX4iMilaAsIbwelxMfCvWNfSD+Gw3++fEhFHTpLFuCBsVJ0ScgUQjw6Az+VatY5PiroHo3IeaeHANlkrh7Qg1NBL43cILUmlMAfqVSXK40QUOSYmHAZHZO0KVkIZgu65kTnWp8Qb+4kHEXfjaDXkhd7DTTmuNZ7MsGyzDYbz5CgSgbdppOBFqqT4l0eX1gZDYOm057heOBQYRl81coZVg9LQWGr+IlrchYKAdJp9h0C6KkvUT3A6u8V1dq4ASqRgZnVnWg04/QWYNyYzC2rD5Y3/hkDgz8fY/cOT1ZjqizMZzGY3rDPC12KGZYyd3J26M8ny1KKx7c3X25q1c1wrZN3L9LCMWs/+AmeG6xI=" target="_blank" rel="noreferrer">Try it in the Playground</a></p><div class="warning custom-block"><p class="custom-block-title">Use with caution</p><p>When using customRef, we should be cautious about the return value of its getter, particularly when generating new object datatypes each time the getter is run. This affects the relationship between parent and child components, where such a customRef has been passed as a prop.</p><p>The parent component&#39;s render function could be triggered by changes to a different reactive state. During rerender, the value of our customRef is reevaluated, returning a new object datatype as a prop to a child component. This prop is compared with its last value in the child component, and since they are different, the reactive dependencies of the customRef are triggered in the child component. Meanwhile, the reactive dependencies in the parent component do not run because the customRef&#39;s setter was not called, and its dependencies were not triggered as a result.</p><p><a href="https://play.vuejs.org/#eNqFVEtP3DAQ/itTS9Vm1ZCt1J6WBZUiDvTQIsoNcwiOkzU4tmU7+9Aq/71jO1mCWuhlN/PyfPP45kAujCk2HSdLsnLMCuPBcd+Zc6pEa7T1cADWOa/bW17nYMPPtvRsDT3UVrcww+DZ0flStybpKSkWQQqPU0IVVUwr58FYvdvDWXgpu6ek1pqSHL0fS0vJw/z0xbN1jUPHY/Ys87Zkzzl4K5qG2zmcnUN2oAqg4T6bQ/wENKNXNk+CxWKsSlmLTSk7XlhedYxnWclYDiK+MkQCoK4wnVtnIiBJuuEJNA2qPof7hzkEoc8DXgg9yzYTBBFgNr4xyY4FbaK2p6qfI0iqFgtgulOe27HyQRy69Dk1JXY9C03JIeQ6wg4xWvJCqFpnlNytOcyC2wzYulQNr0Ao+Mhw0KnTTEttl/CIaIJiMz8NGBHFtYetVrPwa58/IL48Zag4N0ssquNYLYBoW16J0vOkC3VQtVqk7cG9QcHz1kj0QAlgVYkNMFk6d0bJ1pbGYKUkmtD42HmvFfi94WhOEiXwjUnBnlEz9OLTJwy5qCo44D4O7en71SIFjI/F9VuG4jEy/GHQKq5hQrJAKOc4uNVighBF5/cygS0GgOMoK+HQb7+EWvLdMM7weVIJy5kXWi0Rj+xaNRhLKRp1IvB9hxYegA6WJ1xkUe9PcF4e9a+suA3YwYiC5MQ79KlFUzw5rZCZEUtoRWuE5PaXCXmxtuWIkpJSSr39EXXHQcWYNWfP/9A/uV3QUXJjueN2E1ZhtPnSIqGS+er3T77D76Ox1VUn0fsd4y3HfewCxuT2vVMVwp74RbTX8WQI1dy5qx12xI1Fpa1K5AreeEHCCN8q/QXul+LrSC3s4nh93jltkVPDIYt5KJkcIKStCReo4rVQ/CZI6dyEzToCCJu7hAtry/1QH/qXncQB400KJwqPxZHxEyona0xS/E3rt1m9Ld1rZl+uhaxecRtP3EjtgddCyimtXyj9H/Ii3eId7uOGTkyk/wOEbQ9h" target="_blank" rel="noreferrer">See it in the Playground</a></p></div></li></ul><h2 id="shallowreactive" tabindex="-1">shallowReactive() <a class="header-anchor" href="#shallowreactive" aria-label="Permalink to &quot;shallowReactive() {#shallowreactive}&quot;">​</a></h2><p>Shallow version of <a href="./reactivity-core.html#reactive"><code>reactive()</code></a>.</p><ul><li><p><strong>Type</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> shallowReactive</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">target</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span></code></pre></div></li><li><p><strong>Details</strong></p><p>Unlike <code>reactive()</code>, there is no deep conversion: only root-level properties are reactive for a shallow reactive object. Property values are stored and exposed as-is - this also means properties with ref values will <strong>not</strong> be automatically unwrapped.</p><div class="warning custom-block"><p class="custom-block-title">Use with Caution</p><p>Shallow data structures should only be used for root level state in a component. Avoid nesting it inside a deep reactive object as it creates a tree with inconsistent reactivity behavior which can be difficult to understand and debug.</p></div></li><li><p><strong>Example</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> shallowReactive</span><span style="color:#E1E4E8;">({</span></span>\n<span class="line"><span style="color:#E1E4E8;">  foo: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>\n<span class="line"><span style="color:#E1E4E8;">  nested: {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    bar: </span><span style="color:#79B8FF;">2</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// mutating state&#39;s own properties is reactive</span></span>\n<span class="line"><span style="color:#E1E4E8;">state.foo</span><span style="color:#F97583;">++</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// ...but does not convert nested objects</span></span>\n<span class="line"><span style="color:#B392F0;">isReactive</span><span style="color:#E1E4E8;">(state.nested) </span><span style="color:#6A737D;">// false</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// NOT reactive</span></span>\n<span class="line"><span style="color:#E1E4E8;">state.nested.bar</span><span style="color:#F97583;">++</span></span></code></pre></div></li></ul><h2 id="shallowreadonly" tabindex="-1">shallowReadonly() <a class="header-anchor" href="#shallowreadonly" aria-label="Permalink to &quot;shallowReadonly() {#shallowreadonly}&quot;">​</a></h2><p>Shallow version of <a href="./reactivity-core.html#readonly"><code>readonly()</code></a>.</p><ul><li><p><strong>Type</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> shallowReadonly</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">target</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> Readonly</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;</span></span></code></pre></div></li><li><p><strong>Details</strong></p><p>Unlike <code>readonly()</code>, there is no deep conversion: only root-level properties are made readonly. Property values are stored and exposed as-is - this also means properties with ref values will <strong>not</strong> be automatically unwrapped.</p><div class="warning custom-block"><p class="custom-block-title">Use with Caution</p><p>Shallow data structures should only be used for root level state in a component. Avoid nesting it inside a deep reactive object as it creates a tree with inconsistent reactivity behavior which can be difficult to understand and debug.</p></div></li><li><p><strong>Example</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> state</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> shallowReadonly</span><span style="color:#E1E4E8;">({</span></span>\n<span class="line"><span style="color:#E1E4E8;">  foo: </span><span style="color:#79B8FF;">1</span><span style="color:#E1E4E8;">,</span></span>\n<span class="line"><span style="color:#E1E4E8;">  nested: {</span></span>\n<span class="line"><span style="color:#E1E4E8;">    bar: </span><span style="color:#79B8FF;">2</span></span>\n<span class="line"><span style="color:#E1E4E8;">  }</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// mutating state&#39;s own properties will fail</span></span>\n<span class="line"><span style="color:#E1E4E8;">state.foo</span><span style="color:#F97583;">++</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// ...but works on nested objects</span></span>\n<span class="line"><span style="color:#B392F0;">isReadonly</span><span style="color:#E1E4E8;">(state.nested) </span><span style="color:#6A737D;">// false</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// works</span></span>\n<span class="line"><span style="color:#E1E4E8;">state.nested.bar</span><span style="color:#F97583;">++</span></span></code></pre></div></li></ul><h2 id="toraw" tabindex="-1">toRaw() <a class="header-anchor" href="#toraw" aria-label="Permalink to &quot;toRaw() {#toraw}&quot;">​</a></h2><p>Returns the raw, original object of a Vue-created proxy.</p><ul><li><p><strong>Type</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> toRaw</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">proxy</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span></code></pre></div></li><li><p><strong>Details</strong></p><p><code>toRaw()</code> can return the original object from proxies created by <a href="./reactivity-core.html#reactive"><code>reactive()</code></a>, <a href="./reactivity-core.html#readonly"><code>readonly()</code></a>, <a href="#shallowreactive"><code>shallowReactive()</code></a> or <a href="#shallowreadonly"><code>shallowReadonly()</code></a>.</p><p>This is an escape hatch that can be used to temporarily read without incurring proxy access / tracking overhead or write without triggering changes. It is <strong>not</strong> recommended to hold a persistent reference to the original object. Use with caution.</p></li><li><p><strong>Example</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> foo</span><span style="color:#F97583;"> =</span><span style="color:#E1E4E8;"> {}</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> reactiveFoo</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">(foo)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">toRaw</span><span style="color:#E1E4E8;">(reactiveFoo) </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> foo) </span><span style="color:#6A737D;">// true</span></span></code></pre></div></li></ul><h2 id="markraw" tabindex="-1">markRaw() <a class="header-anchor" href="#markraw" aria-label="Permalink to &quot;markRaw() {#markraw}&quot;">​</a></h2><p>Marks an object so that it will never be converted to a proxy. Returns the object itself.</p><ul><li><p><strong>Type</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> markRaw</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#F97583;"> extends</span><span style="color:#79B8FF;"> object</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#FFAB70;">value</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span></span></code></pre></div></li><li><p><strong>Example</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> foo</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> markRaw</span><span style="color:#E1E4E8;">({})</span></span>\n<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">isReactive</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">reactive</span><span style="color:#E1E4E8;">(foo))) </span><span style="color:#6A737D;">// false</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// also works when nested inside other reactive objects</span></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bar</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({ foo })</span></span>\n<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">isReactive</span><span style="color:#E1E4E8;">(bar.foo)) </span><span style="color:#6A737D;">// false</span></span></code></pre></div><div class="warning custom-block"><p class="custom-block-title">Use with Caution</p><p><code>markRaw()</code> and shallow APIs such as <code>shallowReactive()</code> allow you to selectively opt-out of the default deep reactive/readonly conversion and embed raw, non-proxied objects in your state graph. They can be used for various reasons:</p><ul><li><p>Some values simply should not be made reactive, for example a complex 3rd party class instance, or a Vue component object.</p></li><li><p>Skipping proxy conversion can provide performance improvements when rendering large lists with immutable data sources.</p></li></ul><p>They are considered advanced because the raw opt-out is only at the root level, so if you set a nested, non-marked raw object into a reactive object and then access it again, you get the proxied version back. This can lead to <strong>identity hazards</strong> - i.e. performing an operation that relies on object identity but using both the raw and the proxied version of the same object:</p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> foo</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> markRaw</span><span style="color:#E1E4E8;">({</span></span>\n<span class="line"><span style="color:#E1E4E8;">  nested: {}</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> bar</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> reactive</span><span style="color:#E1E4E8;">({</span></span>\n<span class="line"><span style="color:#6A737D;">  // although `foo` is marked as raw, foo.nested is not.</span></span>\n<span class="line"><span style="color:#E1E4E8;">  nested: foo.nested</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(foo.nested </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> bar.nested) </span><span style="color:#6A737D;">// false</span></span></code></pre></div><p>Identity hazards are in general rare. However, to properly utilize these APIs while safely avoiding identity hazards requires a solid understanding of how the reactivity system works.</p></div></li></ul><h2 id="effectscope" tabindex="-1">effectScope() <a class="header-anchor" href="#effectscope" aria-label="Permalink to &quot;effectScope() {#effectscope}&quot;">​</a></h2><p>Creates an effect scope object which can capture the reactive effects (i.e. computed and watchers) created within it so that these effects can be disposed together. For detailed use cases of this API, please consult its corresponding <a href="https://github.com/vuejs/rfcs/blob/master/active-rfcs/0041-reactivity-effect-scope.md" target="_blank" rel="noreferrer">RFC</a>.</p><ul><li><p><strong>Type</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> effectScope</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">detached</span><span style="color:#F97583;">?:</span><span style="color:#79B8FF;"> boolean</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> EffectScope</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#F97583;">interface</span><span style="color:#B392F0;"> EffectScope</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#B392F0;">  run</span><span style="color:#E1E4E8;">&lt;</span><span style="color:#B392F0;">T</span><span style="color:#E1E4E8;">&gt;(</span><span style="color:#B392F0;">fn</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#B392F0;"> T</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> T</span><span style="color:#F97583;"> |</span><span style="color:#79B8FF;"> undefined</span><span style="color:#6A737D;"> // undefined if scope is inactive</span></span>\n<span class="line"><span style="color:#B392F0;">  stop</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> void</span></span>\n<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre></div></li><li><p><strong>Example</strong></p><div class="language-js"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#79B8FF;"> scope</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> effectScope</span><span style="color:#E1E4E8;">()</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8;">scope.</span><span style="color:#B392F0;">run</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>\n<span class="line"><span style="color:#F97583;">  const</span><span style="color:#79B8FF;"> doubled</span><span style="color:#F97583;"> =</span><span style="color:#B392F0;"> computed</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> counter.value </span><span style="color:#F97583;">*</span><span style="color:#79B8FF;"> 2</span><span style="color:#E1E4E8;">)</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">  watch</span><span style="color:#E1E4E8;">(doubled, () </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(doubled.value))</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#B392F0;">  watchEffect</span><span style="color:#E1E4E8;">(() </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;Count: &#39;</span><span style="color:#E1E4E8;">, doubled.value))</span></span>\n<span class="line"><span style="color:#E1E4E8;">})</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D;">// to dispose all effects in the scope</span></span>\n<span class="line"><span style="color:#E1E4E8;">scope.</span><span style="color:#B392F0;">stop</span><span style="color:#E1E4E8;">()</span></span></code></pre></div></li></ul><h2 id="getcurrentscope" tabindex="-1">getCurrentScope() <a class="header-anchor" href="#getcurrentscope" aria-label="Permalink to &quot;getCurrentScope() {#getcurrentscope}&quot;">​</a></h2><p>Returns the current active <a href="#effectscope">effect scope</a> if there is one.</p><ul><li><p><strong>Type</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> getCurrentScope</span><span style="color:#E1E4E8;">()</span><span style="color:#F97583;">:</span><span style="color:#B392F0;"> EffectScope</span><span style="color:#F97583;"> |</span><span style="color:#79B8FF;"> undefined</span></span></code></pre></div></li></ul><h2 id="onscopedispose" tabindex="-1">onScopeDispose() <a class="header-anchor" href="#onscopedispose" aria-label="Permalink to &quot;onScopeDispose() {#onscopedispose}&quot;">​</a></h2><p>Registers a dispose callback on the current active <a href="#effectscope">effect scope</a>. The callback will be invoked when the associated effect scope is stopped.</p><p>This method can be used as a non-component-coupled replacement of <code>onUnmounted</code> in reusable composition functions, since each Vue component&#39;s <code>setup()</code> function is also invoked in an effect scope.</p><ul><li><p><strong>Type</strong></p><div class="language-ts"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki github-dark vp-code" tabindex="0"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#B392F0;"> onScopeDispose</span><span style="color:#E1E4E8;">(</span><span style="color:#B392F0;">fn</span><span style="color:#F97583;">:</span><span style="color:#E1E4E8;"> () </span><span style="color:#F97583;">=&gt;</span><span style="color:#79B8FF;"> void</span><span style="color:#E1E4E8;">)</span><span style="color:#F97583;">:</span><span style="color:#79B8FF;"> void</span></span></code></pre></div></li></ul>',32)];const t=s(o,[["render",function(s,e,l,o,t,c){return n(),a("div",null,p)}]]);export{l as __pageData,t as default};
