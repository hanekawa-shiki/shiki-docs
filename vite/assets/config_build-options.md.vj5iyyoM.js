import{_ as e,o as i,c as t,U as s}from"./chunks/framework.njmvNCfc.js";const g=JSON.parse('{"title":"Build Options","description":"","frontmatter":{},"headers":[],"relativePath":"config/build-options.md","filePath":"config/build-options.md"}'),o={name:"config/build-options.md"},a=s(`<h1 id="build-options" tabindex="-1">Build Options <a class="header-anchor" href="#build-options" aria-label="Permalink to &quot;Build Options&quot;">​</a></h1><h2 id="build-target" tabindex="-1">build.target <a class="header-anchor" href="#build-target" aria-label="Permalink to &quot;build.target&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>string | string[]</code></li><li><strong>Default:</strong> <code>&#39;modules&#39;</code></li><li><strong>Related:</strong> <a href="/guide/build.html#browser-compatibility">Browser Compatibility</a></li></ul><p>Browser compatibility target for the final bundle. The default value is a Vite special value, <code>&#39;modules&#39;</code>, which targets browsers with <a href="https://caniuse.com/es6-module" target="_blank" rel="noreferrer">native ES Modules</a>, <a href="https://caniuse.com/es6-module-dynamic-import" target="_blank" rel="noreferrer">native ESM dynamic import</a>, and <a href="https://caniuse.com/mdn-javascript_operators_import_meta" target="_blank" rel="noreferrer"><code>import.meta</code></a> support. Vite will replace <code>&#39;modules&#39;</code> to <code>[&#39;es2020&#39;, &#39;edge88&#39;, &#39;firefox78&#39;, &#39;chrome87&#39;, &#39;safari14&#39;]</code></p><p>Another special value is <code>&#39;esnext&#39;</code> - which assumes native dynamic imports support and will transpile as little as possible:</p><ul><li>If the <a href="#build-minify"><code>build.minify</code></a> option is <code>&#39;terser&#39;</code> and the installed Terser version is below 5.16.0, <code>&#39;esnext&#39;</code> will be forced down to <code>&#39;es2021&#39;</code>.</li><li>In other cases, it will perform no transpilation at all.</li></ul><p>The transform is performed with esbuild and the value should be a valid <a href="https://esbuild.github.io/api/#target" target="_blank" rel="noreferrer">esbuild target option</a>. Custom targets can either be an ES version (e.g. <code>es2015</code>), a browser with version (e.g. <code>chrome58</code>), or an array of multiple target strings.</p><p>Note the build will fail if the code contains features that cannot be safely transpiled by esbuild. See <a href="https://esbuild.github.io/content-types/#javascript" target="_blank" rel="noreferrer">esbuild docs</a> for more details.</p><h2 id="build-modulepreload" tabindex="-1">build.modulePreload <a class="header-anchor" href="#build-modulepreload" aria-label="Permalink to &quot;build.modulePreload&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean | { polyfill?: boolean, resolveDependencies?: ResolveModulePreloadDependenciesFn }</code></li><li><strong>Default:</strong> <code>{ polyfill: true }</code></li></ul><p>By default, a <a href="https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill" target="_blank" rel="noreferrer">module preload polyfill</a> is automatically injected. The polyfill is auto injected into the proxy module of each <code>index.html</code> entry. If the build is configured to use a non-HTML custom entry via <code>build.rollupOptions.input</code>, then it is necessary to manually import the polyfill in your custom entry:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;vite/modulepreload-polyfill&#39;</span></span></code></pre></div><p>Note: the polyfill does <strong>not</strong> apply to <a href="/guide/build.html#library-mode">Library Mode</a>. If you need to support browsers without native dynamic import, you should probably avoid using it in your library.</p><p>The polyfill can be disabled using <code>{ polyfill: false }</code>.</p><p>The list of chunks to preload for each dynamic import is computed by Vite. By default, an absolute path including the <code>base</code> will be used when loading these dependencies. If the <code>base</code> is relative (<code>&#39;&#39;</code> or <code>&#39;./&#39;</code>), <code>import.meta.url</code> is used at runtime to avoid absolute paths that depend on the final deployed base.</p><p>There is experimental support for fine grained control over the dependencies list and their paths using the <code>resolveDependencies</code> function. <a href="https://github.com/vitejs/vite/discussions/13841" target="_blank" rel="noreferrer">Give Feedback</a>. It expects a function of type <code>ResolveModulePreloadDependenciesFn</code>:</p><div class="language-ts vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">ts</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ResolveModulePreloadDependenciesFn</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  url</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  deps</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[],</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">  context</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    importer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> string</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[]</span></span></code></pre></div><p>The <code>resolveDependencies</code> function will be called for each dynamic import with a list of the chunks it depends on, and it will also be called for each chunk imported in entry HTML files. A new dependencies array can be returned with these filtered or more dependencies injected, and their paths modified. The <code>deps</code> paths are relative to the <code>build.outDir</code>. Returning a relative path to the <code>hostId</code> for <code>hostType === &#39;js&#39;</code> is allowed, in which case <code>new URL(dep, import.meta.url)</code> is used to get an absolute path when injecting this module preload in the HTML head.</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">modulePreload</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  resolveDependencies</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">filename</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">deps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, { </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hostId</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">hostType</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deps.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(condition)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>The resolved dependency paths can be further modified using <a href="./../guide/build.html#advanced-base-options"><code>experimental.renderBuiltUrl</code></a>.</p><h2 id="build-polyfillmodulepreload" tabindex="-1">build.polyfillModulePreload <a class="header-anchor" href="#build-polyfillmodulepreload" aria-label="Permalink to &quot;build.polyfillModulePreload&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean</code></li><li><strong>Default:</strong> <code>true</code></li><li><strong>Deprecated</strong> use <code>build.modulePreload.polyfill</code> instead</li></ul><p>Whether to automatically inject a <a href="https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill" target="_blank" rel="noreferrer">module preload polyfill</a>.</p><h2 id="build-outdir" tabindex="-1">build.outDir <a class="header-anchor" href="#build-outdir" aria-label="Permalink to &quot;build.outDir&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>string</code></li><li><strong>Default:</strong> <code>dist</code></li></ul><p>Specify the output directory (relative to <a href="/guide/#index-html-and-project-root">project root</a>).</p><h2 id="build-assetsdir" tabindex="-1">build.assetsDir <a class="header-anchor" href="#build-assetsdir" aria-label="Permalink to &quot;build.assetsDir&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>string</code></li><li><strong>Default:</strong> <code>assets</code></li></ul><p>Specify the directory to nest generated assets under (relative to <code>build.outDir</code>. This is not used in <a href="/guide/build.html#library-mode">Library Mode</a>).</p><h2 id="build-assetsinlinelimit" tabindex="-1">build.assetsInlineLimit <a class="header-anchor" href="#build-assetsinlinelimit" aria-label="Permalink to &quot;build.assetsInlineLimit&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>number</code></li><li><strong>Default:</strong> <code>4096</code> (4 KiB)</li></ul><p>Imported or referenced assets that are smaller than this threshold will be inlined as base64 URLs to avoid extra http requests. Set to <code>0</code> to disable inlining altogether.</p><p>Git LFS placeholders are automatically excluded from inlining because they do not contain the content of the file they represent.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>If you specify <code>build.lib</code>, <code>build.assetsInlineLimit</code> will be ignored and assets will always be inlined, regardless of file size or being a Git LFS placeholder.</p></div><h2 id="build-csscodesplit" tabindex="-1">build.cssCodeSplit <a class="header-anchor" href="#build-csscodesplit" aria-label="Permalink to &quot;build.cssCodeSplit&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean</code></li><li><strong>Default:</strong> <code>true</code></li></ul><p>Enable/disable CSS code splitting. When enabled, CSS imported in async JS chunks will be preserved as chunks and fetched together when the chunk is fetched.</p><p>If disabled, all CSS in the entire project will be extracted into a single CSS file.</p><div class="tip custom-block"><p class="custom-block-title">Note</p><p>If you specify <code>build.lib</code>, <code>build.cssCodeSplit</code> will be <code>false</code> as default.</p></div><h2 id="build-csstarget" tabindex="-1">build.cssTarget <a class="header-anchor" href="#build-csstarget" aria-label="Permalink to &quot;build.cssTarget&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>string | string[]</code></li><li><strong>Default:</strong> the same as <a href="#build-target"><code>build.target</code></a></li></ul><p>This option allows users to set a different browser target for CSS minification from the one used for JavaScript transpilation.</p><p>It should only be used when you are targeting a non-mainstream browser. One example is Android WeChat WebView, which supports most modern JavaScript features but not the <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb_colors" target="_blank" rel="noreferrer"><code>#RGBA</code> hexadecimal color notation in CSS</a>. In this case, you need to set <code>build.cssTarget</code> to <code>chrome61</code> to prevent vite from transform <code>rgba()</code> colors into <code>#RGBA</code> hexadecimal notations.</p><h2 id="build-cssminify" tabindex="-1">build.cssMinify <a class="header-anchor" href="#build-cssminify" aria-label="Permalink to &quot;build.cssMinify&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean | &#39;esbuild&#39; | &#39;lightningcss&#39;</code></li><li><strong>Default:</strong> the same as <a href="#build-minify"><code>build.minify</code></a></li></ul><p>This option allows users to override CSS minification specifically instead of defaulting to <code>build.minify</code>, so you can configure minification for JS and CSS separately. Vite uses <code>esbuild</code> by default to minify CSS. Set the option to <code>&#39;lightningcss&#39;</code> to use <a href="https://lightningcss.dev/minification.html" target="_blank" rel="noreferrer">Lightning CSS</a> instead. If selected, it can be configured using <a href="./shared-options.html#css-lightningcss"><code>css.lightningcss</code></a>.</p><h2 id="build-sourcemap" tabindex="-1">build.sourcemap <a class="header-anchor" href="#build-sourcemap" aria-label="Permalink to &quot;build.sourcemap&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean | &#39;inline&#39; | &#39;hidden&#39;</code></li><li><strong>Default:</strong> <code>false</code></li></ul><p>Generate production source maps. If <code>true</code>, a separate sourcemap file will be created. If <code>&#39;inline&#39;</code>, the sourcemap will be appended to the resulting output file as a data URI. <code>&#39;hidden&#39;</code> works like <code>true</code> except that the corresponding sourcemap comments in the bundled files are suppressed.</p><h2 id="build-rollupoptions" tabindex="-1">build.rollupOptions <a class="header-anchor" href="#build-rollupoptions" aria-label="Permalink to &quot;build.rollupOptions&quot;">​</a></h2><ul><li><strong>Type:</strong> <a href="https://rollupjs.org/configuration-options/" target="_blank" rel="noreferrer"><code>RollupOptions</code></a></li></ul><p>Directly customize the underlying Rollup bundle. This is the same as options that can be exported from a Rollup config file and will be merged with Vite&#39;s internal Rollup options. See <a href="https://rollupjs.org/configuration-options/" target="_blank" rel="noreferrer">Rollup options docs</a> for more details.</p><h2 id="build-commonjsoptions" tabindex="-1">build.commonjsOptions <a class="header-anchor" href="#build-commonjsoptions" aria-label="Permalink to &quot;build.commonjsOptions&quot;">​</a></h2><ul><li><strong>Type:</strong> <a href="https://github.com/rollup/plugins/tree/master/packages/commonjs#options" target="_blank" rel="noreferrer"><code>RollupCommonJSOptions</code></a></li></ul><p>Options to pass on to <a href="https://github.com/rollup/plugins/tree/master/packages/commonjs" target="_blank" rel="noreferrer">@rollup/plugin-commonjs</a>.</p><h2 id="build-dynamicimportvarsoptions" tabindex="-1">build.dynamicImportVarsOptions <a class="header-anchor" href="#build-dynamicimportvarsoptions" aria-label="Permalink to &quot;build.dynamicImportVarsOptions&quot;">​</a></h2><ul><li><strong>Type:</strong> <a href="https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars#options" target="_blank" rel="noreferrer"><code>RollupDynamicImportVarsOptions</code></a></li><li><strong>Related:</strong> <a href="/guide/features.html#dynamic-import">Dynamic Import</a></li></ul><p>Options to pass on to <a href="https://github.com/rollup/plugins/tree/master/packages/dynamic-import-vars" target="_blank" rel="noreferrer">@rollup/plugin-dynamic-import-vars</a>.</p><h2 id="build-lib" tabindex="-1">build.lib <a class="header-anchor" href="#build-lib" aria-label="Permalink to &quot;build.lib&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>{ entry: string | string[] | { [entryAlias: string]: string }, name?: string, formats?: (&#39;es&#39; | &#39;cjs&#39; | &#39;umd&#39; | &#39;iife&#39;)[], fileName?: string | ((format: ModuleFormat, entryName: string) =&gt; string) }</code></li><li><strong>Related:</strong> <a href="/guide/build.html#library-mode">Library Mode</a></li></ul><p>Build as a library. <code>entry</code> is required since the library cannot use HTML as entry. <code>name</code> is the exposed global variable and is required when <code>formats</code> includes <code>&#39;umd&#39;</code> or <code>&#39;iife&#39;</code>. Default <code>formats</code> are <code>[&#39;es&#39;, &#39;umd&#39;]</code>, or <code>[&#39;es&#39;, &#39;cjs&#39;]</code>, if multiple entries are used. <code>fileName</code> is the name of the package file output, default <code>fileName</code> is the name option of package.json, it can also be defined as function taking the <code>format</code> and <code>entryAlias</code> as arguments.</p><h2 id="build-manifest" tabindex="-1">build.manifest <a class="header-anchor" href="#build-manifest" aria-label="Permalink to &quot;build.manifest&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean | string</code></li><li><strong>Default:</strong> <code>false</code></li><li><strong>Related:</strong> <a href="/guide/backend-integration.html">Backend Integration</a></li></ul><p>When set to <code>true</code>, the build will also generate a <code>.vite/manifest.json</code> file that contains a mapping of non-hashed asset filenames to their hashed versions, which can then be used by a server framework to render the correct asset links. When the value is a string, it will be used as the manifest file name.</p><h2 id="build-ssrmanifest" tabindex="-1">build.ssrManifest <a class="header-anchor" href="#build-ssrmanifest" aria-label="Permalink to &quot;build.ssrManifest&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean | string</code></li><li><strong>Default:</strong> <code>false</code></li><li><strong>Related:</strong> <a href="/guide/ssr.html">Server-Side Rendering</a></li></ul><p>When set to <code>true</code>, the build will also generate an SSR manifest for determining style links and asset preload directives in production. When the value is a string, it will be used as the manifest file name.</p><h2 id="build-ssr" tabindex="-1">build.ssr <a class="header-anchor" href="#build-ssr" aria-label="Permalink to &quot;build.ssr&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean | string</code></li><li><strong>Default:</strong> <code>false</code></li><li><strong>Related:</strong> <a href="/guide/ssr.html">Server-Side Rendering</a></li></ul><p>Produce SSR-oriented build. The value can be a string to directly specify the SSR entry, or <code>true</code>, which requires specifying the SSR entry via <code>rollupOptions.input</code>.</p><h2 id="build-ssremitassets" tabindex="-1">build.ssrEmitAssets <a class="header-anchor" href="#build-ssremitassets" aria-label="Permalink to &quot;build.ssrEmitAssets&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean</code></li><li><strong>Default:</strong> <code>false</code></li></ul><p>During the SSR build, static assets aren&#39;t emitted as it is assumed they would be emitted as part of the client build. This option allows frameworks to force emitting them in both the client and SSR build. It is responsibility of the framework to merge the assets with a post build step.</p><h2 id="build-minify" tabindex="-1">build.minify <a class="header-anchor" href="#build-minify" aria-label="Permalink to &quot;build.minify&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean | &#39;terser&#39; | &#39;esbuild&#39;</code></li><li><strong>Default:</strong> <code>&#39;esbuild&#39;</code></li></ul><p>Set to <code>false</code> to disable minification, or specify the minifier to use. The default is <a href="https://github.com/evanw/esbuild" target="_blank" rel="noreferrer">esbuild</a> which is 20 ~ 40x faster than terser and only 1 ~ 2% worse compression. <a href="https://github.com/privatenumber/minification-benchmarks" target="_blank" rel="noreferrer">Benchmarks</a></p><p>Note the <code>build.minify</code> option does not minify whitespaces when using the <code>&#39;es&#39;</code> format in lib mode, as it removes pure annotations and breaks tree-shaking.</p><p>Terser must be installed when it is set to <code>&#39;terser&#39;</code>.</p><div class="language-sh vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">sh</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">npm</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> add</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> -D</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> terser</span></span></code></pre></div><h2 id="build-terseroptions" tabindex="-1">build.terserOptions <a class="header-anchor" href="#build-terseroptions" aria-label="Permalink to &quot;build.terserOptions&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>TerserOptions</code></li></ul><p>Additional <a href="https://terser.org/docs/api-reference#minify-options" target="_blank" rel="noreferrer">minify options</a> to pass on to Terser.</p><p>In addition, you can also pass a <code>maxWorkers: number</code> option to specify the max number of workers to spawn. Defaults to the number of CPUs minus 1.</p><h2 id="build-write" tabindex="-1">build.write <a class="header-anchor" href="#build-write" aria-label="Permalink to &quot;build.write&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean</code></li><li><strong>Default:</strong> <code>true</code></li></ul><p>Set to <code>false</code> to disable writing the bundle to disk. This is mostly used in <a href="/guide/api-javascript.html#build">programmatic <code>build()</code> calls</a> where further post processing of the bundle is needed before writing to disk.</p><h2 id="build-emptyoutdir" tabindex="-1">build.emptyOutDir <a class="header-anchor" href="#build-emptyoutdir" aria-label="Permalink to &quot;build.emptyOutDir&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean</code></li><li><strong>Default:</strong> <code>true</code> if <code>outDir</code> is inside <code>root</code></li></ul><p>By default, Vite will empty the <code>outDir</code> on build if it is inside project root. It will emit a warning if <code>outDir</code> is outside of root to avoid accidentally removing important files. You can explicitly set this option to suppress the warning. This is also available via command line as <code>--emptyOutDir</code>.</p><h2 id="build-copypublicdir" tabindex="-1">build.copyPublicDir <a class="header-anchor" href="#build-copypublicdir" aria-label="Permalink to &quot;build.copyPublicDir&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean</code></li><li><strong>Default:</strong> <code>true</code></li></ul><p>By default, Vite will copy files from the <code>publicDir</code> into the <code>outDir</code> on build. Set to <code>false</code> to disable this.</p><h2 id="build-reportcompressedsize" tabindex="-1">build.reportCompressedSize <a class="header-anchor" href="#build-reportcompressedsize" aria-label="Permalink to &quot;build.reportCompressedSize&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>boolean</code></li><li><strong>Default:</strong> <code>true</code></li></ul><p>Enable/disable gzip-compressed size reporting. Compressing large output files can be slow, so disabling this may increase build performance for large projects.</p><h2 id="build-chunksizewarninglimit" tabindex="-1">build.chunkSizeWarningLimit <a class="header-anchor" href="#build-chunksizewarninglimit" aria-label="Permalink to &quot;build.chunkSizeWarningLimit&quot;">​</a></h2><ul><li><strong>Type:</strong> <code>number</code></li><li><strong>Default:</strong> <code>500</code></li></ul><p>Limit for chunk size warnings (in kB). It is compared against the uncompressed chunk size as the <a href="https://v8.dev/blog/cost-of-javascript-2019" target="_blank" rel="noreferrer">JavaScript size itself is related to the execution time</a>.</p><h2 id="build-watch" tabindex="-1">build.watch <a class="header-anchor" href="#build-watch" aria-label="Permalink to &quot;build.watch&quot;">​</a></h2><ul><li><strong>Type:</strong> <a href="https://rollupjs.org/configuration-options/#watch" target="_blank" rel="noreferrer"><code>WatcherOptions</code></a><code>| null</code></li><li><strong>Default:</strong> <code>null</code></li></ul><p>Set to <code>{}</code> to enable rollup watcher. This is mostly used in cases that involve build-only plugins or integrations processes.</p><div class="warning custom-block"><p class="custom-block-title">Using Vite on Windows Subsystem for Linux (WSL) 2</p><p>There are cases that file system watching does not work with WSL2. See <a href="./server-options.html#server-watch"><code>server.watch</code></a> for more details.</p></div>`,102),l=[a];function r(n,d,c,p,h,u){return i(),t("div",null,l)}const m=e(o,[["render",r]]);export{g as __pageData,m as default};
